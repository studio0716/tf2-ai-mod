-- AI Bridge - Socket connection via Python helper
-- Uses io.popen to communicate with daemon (avoids native Lua C API issues)

local SOCKET_CLIENT = "/Users/lincolncarlton/Dev/local_ai_builder/bin/socket_client.py"
local connected = false
local lastPoll = 0
local POLL_INTERVAL = 0.5  -- seconds between polls (fast for responsiveness)

-- Debug logging to file
local function log(msg)
    local f = io.open("/tmp/ai_bridge_debug.log", "a")
    if f then
        f:write(os.date("%H:%M:%S") .. " " .. msg .. "\n")
        f:close()
    end
end

-- Send command to daemon via Python helper
local function sendCommand(cmd)
    local p = io.popen("echo '" .. cmd:gsub("'", "'\\''") .. "' | python3 " .. SOCKET_CLIENT, "r")
    if not p then
        log("popen failed")
        return nil
    end
    local result = p:read("*a")
    p:close()
    return result and result:match("^%s*(.-)%s*$")  -- trim
end

-- JSON helpers for sending data
local function toJson(o)
    if type(o) == 'table' then
        local s, first = '{', true
        local isArr = (#o > 0)
        if isArr then s = '[' end
        for k,v in pairs(o) do
            if not first then s = s .. ',' end
            if isArr then s = s .. toJson(v)
            else s = s .. '"' .. tostring(k) .. '":' .. toJson(v) end
            first = false
        end
        return s .. (isArr and ']' or '}')
    elseif type(o) == 'string' then
        return '"' .. o:gsub('\\','\\\\'):gsub('"','\\"'):gsub('\n','\\n') .. '"'
    elseif type(o) == 'boolean' or type(o) == 'number' then
        return tostring(o)
    else
        return 'null'
    end
end

-- Execute Lua code from daemon
local function evalCode(code)
    local env = setmetatable({
        api = api,
        game = game,
        require = require,
        print = print
    }, {__index = _G})

    local func, err = load(code, "eval", "t", env)
    if not func then
        return {status = "error", message = "Compile: " .. tostring(err)}
    end
    local ok, result = pcall(func)
    if ok then
        return {status = "ok", data = result}
    else
        return {status = "error", message = "Runtime: " .. tostring(result)}
    end
end

-- Poll daemon for commands and execute them
local function pollAndExecute()
    local now = os.clock()
    if now - lastPoll < POLL_INTERVAL then
        return
    end
    lastPoll = now

    -- Poll for command
    local response = sendCommand("POLL")
    if not response then
        if connected then
            log("Lost connection to daemon")
            connected = false
        end
        return
    end

    if not connected then
        log("Connected to daemon!")
        connected = true
    end

    -- Check if we got a command
    local command = response:match('"command"%s*:%s*"(.-)"')
    if command then
        -- Unescape the command
        command = command:gsub('\\n', '\n'):gsub('\\"', '"'):gsub('\\\\', '\\')
        log("Executing command: " .. command:sub(1, 50) .. "...")

        -- Execute the Lua code
        local result = evalCode(command)
        log("Result: " .. toJson(result):sub(1, 100))

        -- Send result back to daemon
        local resultJson = toJson(result)
        sendCommand("RESULT:" .. resultJson)
    end
end

-- Main update loop
local initialized = false
local function update()
    if not initialized then
        initialized = true
        log("=== AI_BRIDGE INIT (popen mode) ===")
    end

    -- Poll for commands from daemon
    pollAndExecute()
end

function data()
    log("data() called - script loaded (popen mode)")
    return {
        update = update,
        load = function() log("load() called") end,
        save = function() return {} end
    }
end
