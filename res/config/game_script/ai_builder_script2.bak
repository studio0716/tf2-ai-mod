local gui = require("gui")
local vec2 = require("vec2")
local vec3 = require("vec3")
local helper = require("ai_builder_station_template_helper")
local util = require("ai_builder_util")
local transf  = require("transf")
local pos = nil
local steps = 0
local start = os.clock()
local lastUpdate = start
local nextLineColor = 1
local gui = require "gui"
local zoneutil = require "mission.zone"
local stationCreateTemplateFn
local tracelog = true
local isdebuglog = true
local isAdvancedMode = true
local function trace(...) 
	if tracelog then 
		print(...)
	end
end
local errorPanel
local function err(x)
	print("An error was caught",x)
	print(debug.traceback())
	if errorPanel then errorPanel:setText(_('An error occurred, see logs')) end
	workComplete = true
end
local function debuglog(...) 
	if isdebuglog then 
		print(...)
	end
end
local function year() 
	return game.interface.getGameTime().date.year
end
local circle = {
 radius = math.huge,
 pos = {0,0}
}
local needsupdate = false -- for performance 
local hascircle = false
local workComplete = true
local workItems = {}

local function hypot(x,y)
	return math.sqrt(x*x+y*y)
end
-- takes points
local function hypotlen(p1, p2) 
	return hypot(p2.x-p1.x, p2.y-p1.y)
end
-- takes arrays
local function hypotlen2(p1, p2) 
	return hypot(p2[1]-p1[1], p2[2]-p1[2])
end

local function th(p, useCurrentHeight) 
	return useCurrentHeight and api.engine.terrain.getHeightAt(api.type.Vec2f.new(p.x,p.y)) or
	api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(p.x,p.y))
end
 
local function updateCircle() 
	hascircle = true
	local view = game.gui.getCamera()
	circle.pos = {view[1], view[2]} 
	circle.radius = view[3]/1.8
	game.interface.setZone("ai_builder", {
		polygon=zoneutil.makeCircleZone(circle.pos, circle.radius, 64),
		draw=true,
		drawColor = {0,128,0,1},
	})
end

local function arrayHasValue(tab, val)
    for _, v in pairs(tab) do
        if v == val then
            return true
        end
    end

    return false
end
local function copyEntity(edgeId, transformFn) 
	local entity = api.type.SegmentAndEntity.new()
	entity.entity = -edgeId
	entity.playerOwned =api.engine.getComponent(edgeId, api.type.ComponentType.PLAYER_OWNED)
	entity.comp = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE)
	
	local trackEdge = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE_TRACK)
	if trackEdge then
		entity.trackEdge = trackEdge
		trace("tracktype was ", entity.trackEdge.trackType)
		entity.type = 1
	else 
		entity.type = 0
		entity.streetEdge = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE_STREET)
		
	end
	trace("transforming entity")
	if transformFn then transformFn(entity) end
	return entity
end 
local function kickTrains() 
	for _, vehicleId in pairs(api.engine.system.transportVehicleSystem.getNoPathVehicles()) do
		debuglog("kicking vehicle ", vehicleId)
		api.cmd.sendCommand(api.cmd.make.reverseVehicle(vehicleId))
		api.cmd.sendCommand(api.cmd.make.reverseVehicle(vehicleId))
	end
end
local function deepClone(tab, transform)
    local results = {}
    if type(tab) ~= 'table' and type(tab) ~= 'userdata' then return results end

    for key, value in pairs(tab) do
		if type(value) == 'table' or type(value) == 'userdata'  then
			results[key] = deepClone(value, transform)
		else
			results[key] = transform and transform(value) or value
		end
    end
    return results
end
local function remZone(id)
	game.interface.setZone(id)
	hascircle = false
end

local function newButton(text) 
	local button = api.gui.comp.Button.new(api.gui.comp.TextView.new(text),true)
	button:addStyleClass("AIBuilderButton")
	return button
end

local abortButton
local function toggleAbort() 
	abortButton:setEnabled(#workItems >0)
end
local function doUpgrade(resultView, filterFn, transformFn)
	local count = 0
	local resultCount = 0
	local successCount = 0
	local failedCount = 0
	local function updateView() 
		if count == 0 then
			resultView:setText(_('No segments to upgrade were found'))
		else
			local report = " "..successCount.._(' of ')..count.._(' segments were successfully upgraded. ')..failedCount.._(' failed to upgrade')
			if resultCount < count and #workItems>0 then 
				report = _('In progress:')..report
			else 
				report = _('Completed:')..report
			end
			resultView:setText(report)
		end
	end
	
	debuglog("looking for all entities in radius", circle.radius)
	local edgesForSort = {}
	local edges1dTable = {}
	local constructions = {}
	local segmentonlycount =0 
	for _, edge in pairs(game.interface.getEntities(circle, { type = "BASE_EDGE", includeData = true })) do
		if filterFn(edge) then
			--api.engine.system.streetConnectorSystem.getConstructionEntityForEdge(edge.id)
			local constructionEntity = api.engine.system.streetConnectorSystem.getConstructionEntityForEdge(edge.id)
			trace("inspecting edge.id ", edge.id, " with construction entity ", constructionEntity)
			if not constructionEntity or constructionEntity == -1 then
				count = count + 1
				segmentonlycount = segmentonlycount + 1
				edgesForSort[edge.id]= edge
				table.insert(edges1dTable, edge.id)
			else 
				if not constructions[constructionEntity] then
					count = count + 1
					constructions[constructionEntity]=edge.id
				end
				
				
			end
		end
	end
	updateView()
	table.sort(edges1dTable) -- better to keep neighbouring edges in the same batch
	local edges = {}
	for _, edgeId in pairs(edges1dTable) do
		table.insert(edges, edgesForSort[edgeId]) -- sorting is a pain in lua
	end
	

	
	local batchsize = math.min(128, math.max(16,math.ceil( segmentonlycount / 16)))
	if #edges > 0 and not edges[1].track then 
		local streetType1 =  api.res.streetTypeRep.get(api.engine.getComponent(edges[1].id, api.type.ComponentType.BASE_EDGE_STREET).streetType)
		local streetType2 = api.res.streetTypeRep.get(mapEntity(edges[1]).streetEdge.streetType)
		if streetType1.streetWidth ~= streetType2.streetWidth or streetType1.sidewalkWidth ~= streetType2.sidewalkWidth then
			debuglog("changing street width, setting batch size to 1")
			batchsize = 1 -- changing width may relocate builds, do one by one to avoid crashing
		end
	end
	local submitcount = 0

	updateView() 
	debuglog("segmentonlycount was ", segmentonlycount, " batchsize ", batchsize)
	
	local function callback(res, success) 
			debuglog("upgrade station command result was", tostring(success))
			--if tracelog then debugPrint(res) end
			resultCount = resultCount + 1
			if success then 
				successCount= successCount + 1
			else 
				failedCount = failedCount + 1
			end
			updateView() 
		end
	for constructionId, edgeId in pairs(constructions) do
		local  newProposal  = api.type.SimpleProposal.new()
		local  newProposal  = api.type.SimpleProposal.new()
		local electricupgrade = false
		local highspeedupgrade = false
		local tramelectricupgrade = false
	
		local edge = game.interface.getEntity(edgeId)
		entity = mapEntity(edge)
		--newProposal.streetProposal.edgesToRemove[i]  = edge.id
		--newProposal.streetProposal.edgesToAdd[i] = entity
		
		if edge.track and not api.engine.getComponent(edge.id, api.type.ComponentType.BASE_EDGE_TRACK).catenary  and entity.trackEdge.catenary then 
			electricupgrade = true
		end
		if edge.track and api.engine.getComponent(edge.id, api.type.ComponentType.BASE_EDGE_TRACK).trackType  ~= entity.trackEdge.trackType then 
			highspeedupgrade = true
		end

		if not edge.track and api.engine.getComponent(edge.id, api.type.ComponentType.BASE_EDGE_STREET).tramTrackType ~= entity.streetEdge.tramTrackType then
			tramelectricupgrade = true
		end
		

		debuglog("tramelectricupgrade=", tostring(tramelectricupgrade), " electricupgrade=", tostring(electricupgrade), " highspeedupgrade="..tostring(highspeedupgrade))

		local function transform(x) 
			if highspeedupgrade then
				if x == "station/rail/modular_station/platform_track.module" then 
					return "station/rail/modular_station/platform_high_speed_track.module"
				end
				if x == "station/rail/modular_station/platform_track_catenary.module" then 
					return "station/rail/modular_station/platform_high_speed_track_catenary.module" 
				end
			end
			if electricupgrade then
				if x == "station/rail/modular_station/platform_track.module" then 
					return  "station/rail/modular_station/platform_track_catenary.module" 
				end
				if x == "station/rail/modular_station/platform_high_speed_track.module" then
					return   "station/rail/modular_station/platform_high_speed_track_catenary.module"
				end
			end
			return x
		end
		if tramelectricupgrade or electricupgrade or highspeedupgrade  then
			local name = tramelectricupgrade and "tramelectricupgrade" or electricupgrade and "electricupgrade" or "highspeedupgrade"
			local oldConstruction = api.engine.getComponent(constructionId, api.type.ComponentType.CONSTRUCTION)
			table.insert(workItems, function()
				api.cmd.sendCommand(api.cmd.make.sendScriptEvent("global_upgrade_script.lua", "global_upgrade", name, { id = constructionId, fileName =oldConstruction.fileName, params = nil}), callback)
				debuglog("upgrade command was sent")
				kickTrains()
				workComplete = true
				
			end)
			needsupdate = true
				--[[elseif electricupgrade or highspeedupgrade then
						trace("Setting up construction entity")
				local newConstruction = api.type.SimpleProposal.ConstructionEntity.new()
				
				newConstruction.fileName = oldConstruction.fileName
				local constructionTypeId = api.res.constructionRep.find(oldConstruction.fileName)
				--if tracelog then debugPrint(oldConstruction.params) end
				--trace(type(newConstruction.params))
		 
				local newparams = {}
				for key, value in pairs(oldConstruction.params) do
					trace(key.." type was "..type(value))
					if type(value)~= "table" and type(value)~= "userdata" then
						newparams[key] = value
					end
				end 
			local newparams = cloneDeepOmittingFields(oldConstruction.params, nil, true, transform)
		
			
			
			newparams.seed = oldConstruction.params.seed + 1
		--	newConstruction.params["seed"]=1 -- ??
	--		newConstruction.params.seed = 1
			trace("about to set params")
			if tracelog then debugPrint(newparams) end
			newConstruction.params = newparams--  {seed = 2}
			--newConstruction.params = oldConstruction.params
			trace("Set params, now attempting tansf")
			newConstruction.transf = oldConstruction.transf
			local name = api.engine.getComponent(constructionId, api.type.ComponentType.NAME)
			if name then
				newConstruction.name = name.name
			end
			trace("name set on construction entity")
			local player = api.engine.getComponent(constructionId, api.type.ComponentType.PLAYER_OWNED)
			if player then
				newConstruction.playerEntity = player.player
			end
			trace("Attempting to set consruction on newproposal")
			newProposal.constructionsToAdd[1]=newConstruction
			--newProposal.constructionsToRemove[1]=constructionId
			newProposal.constructionsToRemove  = {constructionId}
			--newProposal.old2new[constructionId] = 1 -- does NOT work
			-- newProposal.old2new[1] = constructionId -- also does NOT work
			--newProposal.old2new[1] = 1 -- also also does NOT work
			newProposal.old2new[constructionId] = 0
			trace("New proposal setup complete, attempting to set context")
			local context = api.type.Context.new()
			 context.cleanupStreetGraph = true
			 context.gatherBuildings = true
			context.player = game.interface.getPlayer()
			if tracelog then debugPrint(newProposal) end
			trace("About to attempt to build proposal")
			local build = api.cmd.make.buildProposal(newProposal, context, true)
			trace("About to send command")
			api.cmd.sendCommand(build, callback)--]]
		else 
			count = count - 1 -- not attempting to upgrade street type / add bus within a station
		end
	end
	updateView() 
	
		for i = 0, #edges, batchsize do
		debuglog("begin outer iteration, i=", tostring(i))
		local  newProposal  = api.type.SimpleProposal.new()
		local attemptCount = 0
		for j = 1, batchsize do
			local index = i+j
    		trace("begin inner iteration, j=", tostring(j), " index=", index)
			if index > #edges then 
				break
			end
			attemptCount = j
			local edge = edges[index]
			if edge == nil then 
				print("no edge at" , index,"#edges",#edges)
				debugPrint(edges)
			end
			entity = mapEntity(edge)
			newProposal.streetProposal.edgesToRemove[j]  = edge.id
			newProposal.streetProposal.edgesToAdd[j] = entity
		end
		if attemptCount == 0 then
			break
		end
		local context = api.type.Context.new()
		context.cleanupStreetGraph = entity.type == 0--true
		context.gatherBuildings = entity.type == 0 --true
		context.player = game.interface.getPlayer()
		trace("About to build proposal")
		local build = api.cmd.make.buildProposal(newProposal, context, false)
		table.insert(workItems, function()
			trace("About to sent command")
			api.cmd.sendCommand(build, function(res, success) 
				debuglog("command result was", tostring(success))
				--if tracelog then debugPrint(res) end
				resultCount = resultCount + attemptCount
				if success then 
					successCount= successCount + attemptCount
				else 
					failedCount = failedCount + attemptCount
					if batchsize > 1 then
						for j = 1, #newProposal.streetProposal.edgesToRemove do
							table.insert(workItems, 1, function()
								local newProposal2  = api.type.SimpleProposal.new()
								newProposal2.streetProposal.edgesToAdd[1] = newProposal.streetProposal.edgesToAdd[j]
								newProposal2.streetProposal.edgesToRemove[1] = newProposal.streetProposal.edgesToRemove[j]
								local build2 = api.cmd.make.buildProposal(newProposal2, context, false)
								api.cmd.sendCommand(build2, function(res, success) 
									debuglog("second attempt command result was", tostring(success))
									if success then 
										failedCount = failedCount - 1
										successCount= successCount + 1
									end
									updateView()
									workComplete = true
								end)
							end)
						end
					end
				end
				updateView() 
			kickTrains()
			debuglog("command was sent")
			workComplete = true
			end)
		end)
		needsupdate = true
		
		submitcount = submitcount + attemptCount
		
	end	
	
end

local function filterYearFrom(edgeType)
	if edgeType.yearFrom == -1 then
		return false
	end
	return edgeType.yearFrom <= year()  
end
local function filterYearTo(edgeType)
	if edgeType.yearTo == -1 then  -- never visible
		return false
	end
	if edgeType.yearTo == 0 then  -- always visible (no end)
		return true
	end
	return edgeType.yearTo > year()
end
local function filterYearFromAndTo(edgeType)
	return filterYearFrom(edgeType) and filterYearTo(edgeType)
end

local function filterRoadEntrances(filename) 
	if string.find(filename,"street_station/entrance") then
		return false 
	end
	if string.find(filename,"street_depot/entrance") then
		return false 
	end
	return true
end







local function buildStraightenPanel() 
	trace("in buildStraightenPanel")
	local boxlayout = api.gui.layout.BoxLayout.new("VERTICAL");
	local resultView = api.gui.comp.TextView.new(" ")
	trace("built boxlayout, resultview")
	local lastResults = {}


local function addSlider(text, params, callback, textFormat) 
		local slider = api.gui.comp.Slider.new(true)
		local textview =  api.gui.comp.TextView.new(text)
		slider:setMinimum(params.minVal)
		slider:setMaximum(params.maxVal)
		slider:setStep(1)
		slider:setPageStep(1)
		slider:onValueChanged(function() 
			textview:setText(textFormat(slider:getValue()))
			callback(slider:getValue())
		end)
		slider:setValue(params.curVal and params.curVal or 5,true)
		local size = slider:calcMinimumSize()
		size.w = size.w+120
		slider:setMinimumSize(size)
		local sliderlayout = api.gui.layout.BoxLayout.new("HORIZONTAL");
		sliderlayout:addItem(api.gui.comp.TextView.new(text))
		sliderlayout:addItem(slider)
		sliderlayout:addItem(textview)
		
		boxlayout:addItem(sliderlayout)
		return sliderlayout
	end
	local curSpeed = 20
	local segmentLimit = 10
	--local tunnelThreashold = 15
	local targetSeglenth = 90
	local maxGradient = 20
	
	boxlayout:addItem(api.gui.comp.TextView.new(_('Common params')))
	trace("added common params text")
	addSlider(_('Max gradient (tries to keep gradients below this limit) '), { minVal = 1, maxVal = 50, curVal = maxGradient}, function(v) maxGradient = v end,function(v) return tostring(v)..'%' end)
	trace("added first slider")
	local checkBoxFollowTerrain =api.gui.comp.CheckBox.new("Try to follow terrain")
	local allowTunnels =api.gui.comp.CheckBox.new("Allow tunnels")
	local allowBridges =api.gui.comp.CheckBox.new("Allow bridges")
	local doubleTrack =api.gui.comp.CheckBox.new("Double track")
	local checkBoxAlignTerrain =  api.gui.comp.CheckBox.new("Strict terrain alignment checking")
	local ignoreErros =api.gui.comp.CheckBox.new("Ignore erros")
	trace("new'd various checkboxes")
	boxlayout:addItem(checkBoxFollowTerrain)
	boxlayout:addItem(allowTunnels)
	boxlayout:addItem(allowBridges)
	boxlayout:addItem(doubleTrack)
	trace("added checkboxes to boxlayout")
		local cleanupStreetGraph =api.gui.comp.CheckBox.new("clean up street graph")
	local gatherBuildings =api.gui.comp.CheckBox.new("Gather buildsings")
	if isAdvancedMode then 
		boxlayout:addItem(checkBoxAlignTerrain)
		boxlayout:addItem(ignoreErros)
		boxlayout:addItem(cleanupStreetGraph)
		boxlayout:addItem(gatherBuildings)
		trace("added isAdvancedMode checkboxes to boxlayout")
	end
	
	boxlayout:addItem(api.gui.comp.Component.new("HorizontalLine"))
	boxlayout:addItem(api.gui.comp.TextView.new(_('Straighten existing connections.')))
	trace("first horizontal line and view")
	addSlider(_('Speed threashold (try to straighten roads under this speed)'), { maxVal = 50, minVal = 1, curVal = curSpeed}, function(v)curSpeed = v end, function(v) return api.util.formatSpeed(v) end)
	addSlider(_('Agressiveness (larger values give bigger changes)'), { maxVal = 25, minVal = 3, curVal = segmentLimit}, function(v) segmentLimit = v end,function(v) return tostring(v).._(' segments')end)
	--addSlider(_('Tunnel threashold gradient'), { minVal = 1, maxVal = 50, curVal = tunnelThreashold}, function(v) tunnelThreashold = v end,function(v) return tostring(v)..'%' end)


	
	local function typeIsCountry(edgeType)
		return edgeType.categories ~= nil and #edgeType.categories > 0 and edgeType.categories[1] == "country" 
	end
	
  	local function isCountry(edge) 
		return typeIsCountry(api.res.streetTypeRep.get(api.engine.getComponent(edge.id, api.type.ComponentType.BASE_EDGE_STREET).streetType))
	
	end
	local function isCountry2(edgeid) 
		return typeIsCountry(api.res.streetTypeRep.get(api.engine.getComponent(edgeid, api.type.ComponentType.BASE_EDGE_STREET).streetType))
	end
	local function typeIsTown(edgeType) 
	return edgeType.categories ~= nil and #edgeType.categories > 0 and edgeType.categories[1] == "urban" 
	end
	local function isTown(edgeid) 
		return typeIsTown(api.res.streetTypeRep.get(api.engine.getComponent(edgeid, api.type.ComponentType.BASE_EDGE_STREET).streetType))
	end
	local function speedthreashold(t)
		local result = t.curveSpeedLimit > 0 and  t.curveSpeedLimit < curSpeed or t.curSpeed > 0 and t.curSpeed < curSpeed 
		trace("t.curveSpeedLimit=", t.curveSpeedLimit, " t.curSpeed=", t.curSpeed, " curSpeed=", curSpeed, " result=", tostring(result))
		return result
	end
	local function speedthreashold3(edgeId)
		if not isCountry2(edgeId) then
			return { result = false  } 
		end
		local edge = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE)
		local nodes = {} 
		nodes[edge.node0] = true
		nodes[edge.node1] = true
		local tn = api.engine.getComponent(edgeId, api.type.ComponentType.TRANSPORT_NETWORK)
			for _, t in pairs(tn.edges) do
				if nodes[t.conns[1].entity] and nodes[t.conns[2].entity]  and speedthreashold(t) then
					trace("edgeId=", edgeId, " DOES meeet speedthreashold")
					return { result = true, curSpeed = t.curSpeed }
				end
			end
		trace("edgeId=", edgeId, " DOES NOT meeet speedthreashold")
		return { result = false  }
	end 
	local function speedthreashold2(edgeId)
		return speedthreashold3(edgeId).result
	end
	 local buttoncheck = newButton(_('Count matching segments')) 

	

	local allowIntersections =api.gui.comp.CheckBox.new("Allow intersections")
	

	trace("about to set default selections on checkboxes")
	checkBoxFollowTerrain:setSelected(true, false)
	allowTunnels:setSelected(true, false)
	allowBridges:setSelected(true, false)
	cleanupStreetGraph:setSelected(true,false)
	gatherBuildings:setSelected(true,false)
	allowIntersections:setSelected(true,false)
	
	trace("completed set default selections on checkboxes")


	if isAdvancedMode then
		boxlayout:addItem(buttoncheck)
	end
	buttoncheck:onClick(function()
			local edges = {}
			local count =0 
		xpcall(function() 
		doUpgrade(api.gui.comp.TextView.new(" "), function(edge) 
		local successCount = 0
		if not edge.track and not edges[edge.id] then
			if isCountry(edge) and speedthreashold2(edge.id) then
				count = count + 1
				debuglog("found edge with id", edge.id, " found ", count)
			end
		end
		
		return false
		end, function(entity) end)
		end,err)
		resultView:setText(count.._(" segments were found"))
		end)
  
    local button = newButton(_('Straighten existing connections'))
	    boxlayout:addItem(button)
		local combobox = api.gui.comp.ComboBox.new()
	
	boxlayout:addItem(api.gui.comp.Component.new("HorizontalLine"))
	boxlayout:addItem(api.gui.comp.TextView.new(_('Add new city connections.')))
	local streetChoicesLayout =  api.gui.layout.BoxLayout.new("HORIZONTAL");
	streetChoicesLayout:addItem(api.gui.comp.TextView.new(_('New connection street type:')))
	streetChoicesLayout:addItem(combobox)
	trace("added second horizonal line")
	boxlayout:addItem(streetChoicesLayout)
	local buildBusStops =api.gui.comp.CheckBox.new(_("Build bus stops"))
	buildBusStops:setSelected(true, false)
	boxlayout:addItem(buildBusStops)
	local buildBusStopsTown =api.gui.comp.CheckBox.new(_("Build central town stops"))
	buildBusStopsTown:setSelected(true, false)
	boxlayout:addItem(buildBusStopsTown)
	local buildRoadDepot =api.gui.comp.CheckBox.new(_("Build road depot"))
	buildRoadDepot:setSelected(true, false)
	boxlayout:addItem(buildRoadDepot)
	boxlayout:addItem(allowIntersections)
	local threasholdAngle = 30
	local townSearchDistance = 3000
	local roadDepotExtraAngle = 270
	local roadDepotPoistionOffset = 60
	trace("adding road depot extra angle")
	addSlider(_('Road depot extra angle'), { minVal = 0, maxVal = 270, curVal = roadDepotExtraAngle}, function(v) roadDepotExtraAngle = v end,function(v) return tostring(roadDepotExtraAngle).._(" degrees") end)
		trace("adding road depot position offset")
	addSlider(_('roadDepotPoistionOffset'), { minVal = 0, maxVal = 120, curVal = roadDepotPoistionOffset}, function(v) roadDepotPoistionOffset = v end,function(v) return api.util.formatLength( v) end)
	
	
	addSlider(_('Search radius for finding other towns'), { minVal = 1, maxVal = 24, curVal = townSearchDistance/1000}, function(v) townSearchDistance = 1000*v end,function(v) return api.util.formatLength(1000*v) end)
	addSlider(_('Straightness factor (lower values more straight)'), { minVal = 0, maxVal = 180, curVal = threasholdAngle}, function(v) threasholdAngle = v end,function(v) return tostring(v)..' degrees' end)
	if isAdvancedMode then
		addSlider(_('Target segment length'), { minVal = 1, maxVal = 50, curVal = targetSeglenth/10}, function(v) targetSeglenth = 10*v end,function(v) return tostring(v)..'0' end)
	end
	local stationAngleThreashold = 20
	addSlider(_('Station angle threashold'), { minVal = 1, maxVal = 90, curVal = stationAngleThreashold}, function(v) stationAngleThreashold =  v end,function(v) return tostring(v).._(' degrees') end)
	local lookup1 = {}
	local function populateChoices() 
		combobox:clear(false)
	 
		for __, filename in pairs(api.res.streetTypeRep.getAll()) do
			local i = api.res.streetTypeRep.find(filename) -- cannot trust the index from getAll, flips between 0 and 1 based 
			local edgeType = api.res.streetTypeRep.get(i)
			if typeIsCountry(edgeType) and filterYearFromAndTo(edgeType) then
				combobox:addItem( edgeType.name)
				lookup1[combobox:getNumItems()]=i
			end
		end
		if combobox:getNumItems() > 0 then
			combobox:setSelected(0, false)
		end
		
	end
	trace("added populateChoices combobox")
	

	local function v3(p)
	return vec3.new(p.x, p.y, p.z)
	end
	local function v3fromArr(p)
	return vec3.new(p[1], p[2], p[3])
	end
	local function nodePos2(node)
	return api.engine.getComponent(node, api.type.ComponentType.BASE_NODE).position
end
local function nodePos(node)
	return v3(nodePos2(node))
end

local function get3DLength(edge)
	local p0 = point3New(edge.p0)
	local p1 = point3New(edge.p1)
	local t0 = point3New(edge.t0)
	local t1 = point3New(edge.t1)
	return calcEdgeLength(p0, p1, t0, t1)
end	


local function calcEdgeLength(p0, p1, t0, t1) -- more exact than other methods
	local function derivative(t)
		local c0 = t0
		local c1 = 6 * (p1 - p0) - 4 * t0 - 2 * t1 -- only pre-defined vec3 objects!
		local c2 = 6 * (p0 - p1) + 3 * (t0 + t1)
		return vec3.length(c0 + t * (c1 + t * c2))
	end

	local gaussLengendreCoeff = {
		{0, .5688889},
		{-.5384693, .47862867},
		{.5384693, .47862867},
		{-.90617985, .23692688},
		{.90617985, .23692688}
	}

	local lg = 0
	for _, v in pairs(gaussLengendreCoeff) do
		lg = lg + derivative(.5 * (1 + v[1])) * v[2]
	end
	return .5 * lg
end
	
local function getEdgeBasics(edgeId, directionIndex)
	local entity = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE)
	-- Fun with lua! ;-) Long 'debugPrint' outputs cause 'garbage collections' destroying USERDATA blocks.
	-- This will also destroy data in EVERY table which refers to these blocks using only pointers.
	-- So we have to copy every single parameter to our new table so that we get an independent table:
	if entity then
		local p0, p1, t0, t1
		if not directionIndex or directionIndex == 0 then
			p0 =  point3New(getNodePos(entity.node0))
			p1 =  point3New(getNodePos(entity.node1))
			t0 = point3New(entity.tangent0)
			t1 = point3New(entity.tangent1)
		else
			p0 = point3New(getNodePos(entity.node1))
			p1 = point3New(getNodePos(entity.node0))
			t0 = -1 * point3New(entity.tangent1)
			t1 = -1 * point3New(entity.tangent0)
		end
		local edge = {
			id = edgeId,
			t0 = t0,
			t1 = t1,
			p0 = p0,
			p1 = p1,
			p0Id = entity.node0,
			p1Id = entity.node1,
		}
		local lg = get3DLength(edge)
		return {
			edge = edge,
			lg = lg,
		}
	end
end	
 local function findBridgeType(split)
	if split and  year() >=1925 and (split.bridgeLength and split.bridgeLength > 5
		or split.bridgeHeight and split.bridgeHeight > 50)
	then
		return api.res.bridgeTypeRep.find("suspension.lua")
	end
 
 -- see if "cement" is available, fall back to stone 
	local cement = api.res.bridgeTypeRep.find("cement.lua")
	if api.res.bridgeTypeRep.get(cement).yearFrom >= year() then
		return cement
	else 
		return api.res.bridgeTypeRep.find("stone.lua")
	end
end
 
local function convertHermiteToBezier(edge) -- edge must contain vec3 objects
	local oneThird = 1 / 3

	local b0 = edge.p0 -- b instead of p/t for absolute Bezier points, like Wikipedia example
	local b1 = edge.p0 + oneThird * edge.t0
	local b2 = edge.p1 - oneThird * edge.t1
	local b3 = edge.p1

	return b0, b1, b2, b3
end

local function convertBezierToHermite(b0, b1, b2, b3) -- arguments must be vec3 objects
	local p0 = b0 
	local p1 = b3
	local t0 = 3 * (b1 - b0)
	local t1 = 3 * (b3 - b2)

	return p0, p1, t0, t1
end

local function deCasteljau(b0, b1, b2, b3, t)
	local b1n = b0 + t * (b1 - b0)
	local b1b2 = b1 + t * (b2 - b1)
	local b5n = b3 + (1 - t) * (b2 - b3)
	local b2n = b1n + t * (b1b2 - b1n)
	local b4n = b1b2 + t * (b5n - b1b2)
	local b3n = b2n + t * (b4n - b2n)

	return b1n, b2n, b3n, b4n, b5n
end
local function pow(x, y)
	return x^y; --Math.pow(x,y)
end
   --[[  
-- from https://stackoverflow.com/questions/7205832/as3-function-for-extrapolating-points-on-a-spline-curve-or-hermite-curve-similar
		/*
         * Computes x,y values for a given traversal of a Hermite Curve
         * @param t:Number - a normalized value (0.0 to 1.0) describing path traversal
         * @param points:Array - an array contining the 4 points describing the curve (P0,T0,P1,T1 - always in this order)
         * Anchor points are relative to they're control points
         */--]]
	local function hermite(t, p0, m0, p1, m1)
	-- cubic hermite equation for 0<=t<=1, m means tangent. Source https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Unit_interval_(0,_1)
	-- p(t) = (2t^3-3t^2+1)p0 + (t^3-2t^2+t)m0 + (-2t^3 + 3t^2)p1 + (t^3-t^2)m1

		return {
			p = vec3.new
			(
			-- x =
				(2 * t^3 - 3 * t^2 + 1) * p0.x+
				(t^3 - 2 * t^2 + t) * m0.x + 
				(- 2 * t^3 + 3*t^2) * p1.x +
				( t^3 - t^2) * m1.x,
			-- y =
				(2 * t^3 - 3 * t^2 + 1) * p0.y+
				(t^3 - 2 * t^2 + t) * m0.y + 
				(- 2 * t^3 + 3*t^2) * p1.y +
				( t^3 - t^2) * m1.y,
			-- z =
				(2 * t^3 - 3 * t^2 + 1) * p0.z+
				(t^3 - 2 * t^2 + t) * m0.z + 
				(- 2 * t^3 + 3*t^2) * p1.z +
				( t^3 - t^2) * m1.z
			),
			-- thank you to wolframalpha https://www.wolframalpha.com/input?i=derivative+of+p%28t%29+%3D+%282t%5E3-3t%5E2%2B1%29p0+%2B+%28t%5E3-2t%5E2%2Bt%29m0+%2B+%28-2t%5E3+%2B+3t%5E2%29p1+%2B+%28t%5E3-t%5E2%29m1
			-- p'(t) = m0 (3 t^2 - 4 t + 1) + m1 (3 t - 2) t + 6 (t - 1) t (p0 - p1)
			t = vec3.new
			(
				m0.x * (3*t^2 - 4*t + 1) + m1.x * (3*t - 2) * t + 6 * (t - 1) * t * (p0.x - p1.x),
				m0.y * (3*t^2 - 4*t + 1) + m1.y * (3*t - 2) * t + 6 * (t - 1) * t * (p0.y - p1.y),
				m0.z * (3*t^2 - 4*t + 1) + m1.z * (3*t - 2) * t + 6 * (t - 1) * t * (p0.z - p1.z)
			)
						
		}
	end

local function hypot3d(t) 
	return math.sqrt(t.x^2+t.y^2+t.z^2)
end

local function normaliseTangent(p0, t0, p1, t1)
	local l =  calcEdgeLength(p0, p1, t0, t1)
	t0.x = l/hypot3d(t0) * t0.x
	t0.y = l/hypot3d(t0) * t0.y
	t0.z = l/hypot3d(t0) * t0.z
	t1.x = l/hypot3d(t1) * t1.x
	t1.y = l/hypot3d(t1) * t1.y
	t1.z = l/hypot3d(t1) * t1.z
end

local function recursiveSplitter(edge, oldNode, numberOfNodes, nodeOrder, lastSplit, context)
	trace("setting up recursiveSplitter")
	--local pos = nodePos(oldNode)
	local highestFrozen  = math.max(edge.p0.z,edge.p1.z)
	local lowestFrozen  = math.min(edge.p0.z,edge.p1.z)
	local minHeight = (edge.p0.z > 100 and edge.p1.z> 100) and lowestFrozen or 0
	local minbridgeHeight = 10
	local minTunnelDepth = 10
	local minBridgeHeightAboveGround = 5
	local maxbridgeHeight = 30
	local tunnelThreashold = math.min(maxGradient+10, 20)
 
	local simpleLenght = hypotlen(edge.p0, edge.p1) 
	local totalsegs= numberOfNodes+1
	local fracspace = 1/ (totalsegs ) 
	local strictFrac = nodeOrder / totalsegs 

	trace( " simpleLenght=", simpleLenght, " totalsegs=", totalsegs, " strictFrac=", strictFrac, " nodeOrder=", nodeOrder, " calculating new node point")
	local function isBridge(i)
		return context.bridgeStart and context.bridgeStart >= 0 and i >= context.bridgeStart and i <= context.bridgeEnd
	end
	local function isTunnelCandidateFn(i)
		return context.tunnelStart and (context.tunnelStart >= 0 and i >= context.tunnelStart and i <= context.tunnelEnd or context.tunnelHeights[i])
	end
	
	local function gradBetween(i, j) 
		return 100*((context.terrainHeights[i] - context.terrainHeights[j]) / (math.abs(i-j)*context.seglength))
	end

	local function leftGrad(i)
		return gradBetween(i, i-1)
	end
	
	local function smoothToTerrain(i, deltaz)
		if 
		context.terrainHeights[i] <0 or
		--isTunnelCandidateFn(i-1) or isBridge(i-1) or
		isTunnelCandidateFn(i)
		--or isTunnelCandidateFn(i+1) or isBridge(i+1)
		then 
			return 
		end
		if  isBridge(i) and not context.bridgeOverTerrain then 
			return 
		end
		
		local maxDeltaZ = (maxGradient/100)*context.seglength
		if context.actualHeights[i]~=context.terrainHeights[i] then
			local terraingap = context.terrainHeights[i]- context.actualHeights[i]
			local deltaRemaining = deltaz< 0 and deltaz + maxDeltaZ or maxDeltaZ - deltaz
			assert(deltaRemaining>=0, "deltaz="..deltaz.." maxDeltaZ="..maxDeltaZ.." deltaRemaining="..deltaRemaining)
			if deltaz > 0 and terraingap <0 then  
				deltaRemaining = deltaz + maxDeltaZ
			elseif deltaz < 0 and terraingap >0 then
				deltaRemaining = math.abs(deltaz)+maxDeltaZ
			end
			
			local adjustment = terraingap >0 and math.min(terraingap, deltaRemaining) or math.max(terraingap,-deltaRemaining)
			
			context.actualHeights[i]=math.max(minHeight, context.actualHeights[i]+adjustment)
			trace("adjusted height at ",i," by",adjustment, "deltaz=",deltaz, "terraingap=",terraingap, " deltaRemaining=",deltaRemaining, " maxDeltaZ=",maxDeltaZ, " new deltaz=", context.actualHeights[i]-context.actualHeights[i-1])
		end
	end

	local function smooth(from, to)
		trace("smoothing from ",from," to ", to)
		local maxDeltaZ = (maxGradient/100)*context.seglength
		for i = from, to do
			local deltaz = context.actualHeights[i]-context.actualHeights[i-1]
			local hbefore=context.actualHeights[i]
			if deltaz > maxDeltaZ then
				context.actualHeights[i]= context.actualHeights[i-1]+maxDeltaZ
				trace("clamped height at ",i," due to deltaz=",deltaz, "maxDeltaZ=",maxDeltaZ, " hbefore=",hbefore, " context.actualHeights[i]=",context.actualHeights[i], " terrainheight=",context.terrainHeights[i])
				smoothToTerrain(i, maxDeltaZ)
			elseif deltaz < -maxDeltaZ then
				context.actualHeights[i]= context.actualHeights[i-1]-maxDeltaZ
				trace("clamped height at ",i," due to deltaz=",deltaz, "maxDeltaZ=",maxDeltaZ, " hbefore=",hbefore, " context.actualHeights[i]=",context.actualHeights[i])
				smoothToTerrain(i, -maxDeltaZ)
			else	
				smoothToTerrain(i, deltaz)
			end
		end
	end
	local function reversesmooth(from, to)
		trace("reverse smoothing from ",from," to ", to)
		local maxDeltaZ = (maxGradient/100)*context.seglength
		for i = from, to, -1 do
			local deltaz = context.actualHeights[i]-context.actualHeights[i+1]
			local hbefore=context.actualHeights[i]
			if deltaz > maxDeltaZ then
				context.actualHeights[i]= context.actualHeights[i+1]+maxDeltaZ
				trace("reverse clamped height at ",i," due to deltaz=",deltaz, "maxDeltaZ=",maxDeltaZ," hbefore=",hbefore, " context.actualHeights[i]=",context.actualHeights[i])
			elseif deltaz < -maxDeltaZ then
				context.actualHeights[i]= context.actualHeights[i+1]-maxDeltaZ
				trace("reverse clamped height at ",i," due to deltaz=",deltaz, "maxDeltaZ=",maxDeltaZ," hbefore=",hbefore, " context.actualHeights[i]=",context.actualHeights[i])
			else
				smoothToTerrain(i, deltaz)
			end
		end
	end

	if nodeOrder == 1 then 
		-- init
		context.seglength =calcEdgeLength(edge.p0,edge.p1,edge.t0,edge.t1)/(numberOfNodes+1)
		context.terrainHeights = {}
		context.hermiteHeights ={}
		context.gradients = {}
		context.terrainHeights[0] = edge.p0.z -- fixed
		context.hermiteHeights[0] = edge.p0.z
		context.gradients[0] = 0
		for i = 1, numberOfNodes do
			local p = hermite(i / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p
			context.terrainHeights[i]=th(p)
			context.hermiteHeights[i]=p.z
			context.gradients[i]=leftGrad(i)
		end
		context.terrainHeights[numberOfNodes+1] = edge.p1.z -- fixed
		context.hermiteHeights[numberOfNodes+1] = edge.p1.z
		context.gradients[numberOfNodes+1]=0
		
		context.actualHeights = {}
		for i, h in pairs(context.terrainHeights) do
			local minh = math.max(minHeight, h<0 and minbridgeHeight or 0)
			context.actualHeights[i]=math.max(h,minh)
		end
		smooth(1, numberOfNodes)
		reversesmooth(numberOfNodes, 1)
	end

	

	
	local function searchForBridges(startFrom)
		context.bridgeMaxHeight = nil
		context.bridgeStartHeight = 0
		context.bridgeStart = -1
		context.bridgeEnd = -1
		context.bridgeEndHeight = 0
		context.bridgeLength = 0
		for i= startFrom, numberOfNodes do
			--if isTunnelCandidateFn(i) then
			--	searchForBridges(i+1)-- reset the context
			--	return
			--end
			local p = hermite(i / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p
			local terrainHeight = th(p)
			local leftterrainHeight = context.terrainHeights[i]
			local minterrainHeight = terrainHeight
			for k = 1, 4 do -- need to look at points along the segment
				local p2 = hermite((i-k/5) / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p
				minterrainHeight = math.min(minterrainHeight, api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(p2.x,p2.y)))
			end
			-- search for bridges
			local leftGrad = leftGrad(i)
			local bridgeOverTerrain = terrainHeight < highestFrozen  and (context.actualHeights[i] >= minbridgeHeight+context.terrainHeights[i])
 			trace("checking for bridge at i=", i, " terrainHeight=", terrainHeight, " x,y=", p.x, ",", p.y, " minterrainHeight=", minterrainHeight, "leftgrad=",leftGrad, "bridgeOverTerrain=",bridgeOverTerrain)
			if minterrainHeight <0 or bridgeOverTerrain then 
				if context.bridgeStart == -1 then 
					context.bridgeStart = i-1
					context.bridgeOverTerrain = minterrainHeight >=0
					--context.bridgeStartHeight = minterrainHeight < 0 and context.terrainHeights[i-1]+minBridgeHeightAboveGround or context.actualHeights[i-1]
					context.bridgeStartHeight = math.max(context.terrainHeights[i-1]+minBridgeHeightAboveGround , context.actualHeights[i-1])
					if i > 1 and not context.bridgeOverTerrain then
						-- smooth out ramp
						context.bridgeStartHeight =  math.max(context.bridgeStartHeight, context.terrainHeights[i-2])
					end
					trace("bridge started at ", tostring(i-1), " context.bridgeStartHeight=", context.bridgeStartHeight)
				else 
					context.bridgeLength = context.bridgeLength + 1
					trace("bridge continued at ", tostring(i))
				end
			elseif context.bridgeStart ~= -1 and context.bridgeEnd == -1 then
				-- short look ahead to the next two nodes as may form continuous bridge
				if not context.bridgeOverTerrain and ((i <numberOfNodes and context.terrainHeights[i+1] <0)
					or (i <numberOfNodes-1 and context.terrainHeights[i+2] <0)) then
					context.bridgeLength = context.bridgeLength + 1
					trace("bridge continued due to look ahead at ", tostring(i))
				else
					context.bridgeLength = context.bridgeLength + 1
					context.bridgeEnd = i
					context.bridgeEndHeight = math.max(terrainHeight+minBridgeHeightAboveGround, context.actualHeights[i])
					if context.bridgeOverTerrain and math.abs(gradBetween(context.bridgeStart, i)) > maxGradient then 
						trace("bridge cancelled at ", i, " due to high gradient")
						searchForBridges(i)
					else
						trace("bridge finished at ", tostring(i))
						local b = context.actualHeights[context.bridgeStart]
						local a = (context.bridgeEndHeight - b) / (context.bridgeLength+1)
						
						for j = context.bridgeStart, context.bridgeEnd do 
							local x = j-context.bridgeStart
							context.actualHeights[j]=a*x + b
							trace("bridge calculation, setting context.actualHeights[j]=",context.actualHeights[j]," a=",a," x=",x," b=",b)
						end
						context.bridgeMaxHeight = math.max(b,context.actualHeights[context.bridgeEnd])
						smooth(i+1, numberOfNodes)
					end
					break
				end
			end
			::continue::
		end
		if context.bridgeStart~=-1 and context.bridgeEnd==-1 then
			context.bridgeEnd=numberOfNodes
			context.bridgeLength=1+context.bridgeEnd-context.bridgeStart
			context.bridgeEndHeight = th(edge.p1)
			context.bridgeMaxHeight = math.max(context.bridgeEndHeight,context.bridgeStartHeight)
			reversesmooth(numberOfNodes, context.bridgeStart)
			trace("bridge automatically finished at ", tostring(numberOfNodes))
		end
	
	end
	
	local function maxAbsGradient(from, to) 
		local maxgrad = 0
		for i = from, math.min(to, numberOfNodes+1) do
			--trace("checking gradient at ",i)
			maxgrad = math.max(maxgrad, math.abs(context.gradients[i]))
		end
		return maxgrad
	end
	
	local function searchForTunnels(startFrom)
		local previousTunnelEnd = (context.tunnelEnd and context.tunnelEnd ~= 1) and context.tunnelEnd or 1
		context.tunnelStart = -1
		context.tunnelEnd = -1
		context.tunnelHeight = nil
		context.tunnelHeights = {}
		if not allowTunnels:isSelected() then
			return
		end
		local rightHandSearch = numberOfNodes
	
		for i= 	startFrom, numberOfNodes do
			 
			-- search for tunnels in the current direction
			local pleft = hermite((i-1) / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p
			local p = hermite(i / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p	
			local pright = hermite((i+1) / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p
			local terrainHeight = th(p, i==numberOfNodes)
			local leftterrainHeight = i==1 and pleft.z or th(pleft)
			if i==1 then 
				trace(" pleft.x=",pleft.x," pleft.y=",pleft.y, " pleft.z= ",pleft.z, " edge.p0.x=", edge.p0.x, " edge.p0.y=", edge.p0.y, " edge.p0.z=", edge.p0.z,"  api.engine.terrain.getHeightAt(api.type.Vec2f.new(edge.p0.x,edge.p0.y))=", api.engine.terrain.getHeightAt(api.type.Vec2f.new(edge.p0.x,edge.p0.y)))
			end
			
	 
			local leftgrad = 100*((terrainHeight - leftterrainHeight) / hypotlen(p, pleft))
			trace("looking for tunnel at ", tostring(i), " leftGrad was ", leftgrad, " leftterrainHeight=",leftterrainHeight, " terrainHeight=",terrainHeight, " p.x=", p.x, " p.y=", p.y, " calculated leftgrad was",leftGrad(i))
			local lowlimit = lowestFrozen - 10
			if leftterrainHeight>=lowlimit and terrainHeight>=lowlimit and leftgrad >= tunnelThreashold and context.tunnelStart == -1 then
				trace("tunnel started at ", tostring(i), " leftGrad was ", leftgrad)
				context.tunnelStart = i -- - 1
				context.tunnelHeight = math.max(math.min(leftterrainHeight, terrainHeight-10),context.hermiteHeights[i]-20)
				context.actualHeights[i] = context.tunnelHeight
				reversesmooth(i-1, previousTunnelEnd)
			elseif context.tunnelStart ~= -1 and context.tunnelEnd == -1 and (
			(context.tunnelHeight+10) >= terrainHeight
			or context.hermiteHeights[i]+10 >= terrainHeight
			or maxAbsGradient(i, i+5) < tunnelThreashold -- implies smooth terrain ahead, we should exit 
			)
			then
				context.tunnelEnd = i-1
				if context.tunnelEnd == context.tunnelStart then
					trace("tunnel ended on the same point as the start, searching for next at ",i)
					smooth(i-1,i)
					searchForTunnels(i)
					return
				end
				
				for j = context.tunnelStart, context.tunnelEnd do 
					local height = context.tunnelHeight
					if math.abs(context.tunnelHeight-terrainHeight) > 10 then
						local tunnellength = context.tunnelEnd - context.tunnelStart 
						local b = context.tunnelHeight
						local a = (terrainHeight - b) / (tunnellength+1)
						local x = j-context.tunnelStart
						height = a*x+b
					end
					context.tunnelHeights[j]=height
					context.actualHeights[j] = height
					trace("tunnel end setting context.actualHeights[j] ", j, " to ",context.actualHeights[j]," a=",a," x=",x," b=",b )
				end
				context.actualHeights[i]=context.tunnelHeight
				smooth(i , numberOfNodes)
				
				trace("left tunnel ended at ", (i-1), "(context.tunnelHeight+10) >= terrainHeight ", (context.tunnelHeight+10) >= terrainHeight, "context.tunnelHeight+10=",context.tunnelHeight+10)
				break
			end
		end
		
		if context.tunnelStart ~= -1 and context.tunnelEnd == -1 then
			context.tunnelEnd = numberOfNodes
			local tunnellength = context.tunnelEnd - context.tunnelStart
			if tunnellength > 0 then
				local b = context.tunnelStart
				local a = (edge.p1.z - b) / tunnellength
			
				for j = context.tunnelStart, context.tunnelEnd do 
					local x = j-context.tunnelStart
					local h = a*x + b
					context.tunnelHeights[j]=h 
					context.actualHeights[j]=h
					trace("End tunnel setting height at ",j," to ",h)
				end
			else
				context.tunnelStart = -1
				context.tunnelEnd = -1
			end
		end
		
		-- search for tunnels in the opposite direction
		if context.tunnelStart == -1 then
			local isTunnel = false -- overwrite to left most results
			for i = numberOfNodes, startFrom, -1 do
				local pright = hermite((i+1) / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p
				local p = hermite(i / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p	
				local terrainHeight = api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(p.x,p.y))
				local rightterrainHeight =	api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(pright.x,pright.y))
				local rightGrad = 100*((terrainHeight - rightterrainHeight ) / hypotlen(p, pright))
				trace("looking for tunnel at ", tostring(i), " rightGrad was ", rightGrad)
				local lowlimit = math.max(minHeight, lowestFrozen - 10)
				if rightterrainHeight>=lowlimit and terrainHeight>=lowlimit and rightGrad >= tunnelThreashold and not isTunnel then
					isTunnel = true
					trace("right tunnel started at ", tostring(i), " rightGrad was ", rightGrad)
					context.tunnelEnd = i
					context.tunnelHeight = math.min(rightterrainHeight, terrainHeight-10)
					context.actualHeights[i]=context.tunnelHeight
					smooth(i,numberOfNodes)
				end
				if context.tunnelEnd ~= -1 and isTunnel and (context.tunnelHeight+10) >= terrainHeight then
					context.tunnelStart = i
					isTunnel = false
					trace("right tunnel ended at ", tostring(i))
					for j = context.tunnelStart, context.tunnelEnd do 
						context.tunnelHeights[j]=context.tunnelHeight
						context.actualHeights[j] = context.tunnelHeight
						trace("right tunnel end, setting context.actualHeights[j] ", j, " to ",context.actualHeights[j] )
					end
					reversesmooth(i, previousTunnelEnd)
					break
				end
			end
		end
		if context.tunnelEnd ~= -1 and context.tunnelStart == -1 then
			context.tunnelStart = startFrom
			local tunnellength = context.tunnelEnd - context.tunnelStart 
			if tunnellength==0 then
				trace("cancelling tunnel of zero length at ",startFrom)
				context.tunnelStart = -1
				context.tunnelEnd = -1
				return
			end
		
			local tunnelStartHeight = startFrom == 1 and edge.p0.z or hermite(startFrom / totalsegs, edge.p0,edge.t0,edge.p1,edge.t1).p	.z
			local b =tunnelStartHeight
			local a = ( context.tunnelHeight-b) / (tunnellength+1)
				
			for j = context.tunnelStart, context.tunnelEnd do 
				local x = j-context.tunnelStart
				local h = a*x + b
				if h < context.terrainHeights[j] then
					context.tunnelHeights[j]=h
					context.actualHeights[j]=h
					trace("End tunnel setting height at ",j," to ",h, " b=",b," a=",a)
				end
			end
		end
		
	
	end
	
	if nodeOrder == 1 then 
		searchForTunnels(nodeOrder)
		searchForBridges(nodeOrder)
		
	end
	
	-- need three points for smooth z tangents
	local lpos = nodeOrder == 1 and { p = edge.p0, t = edge.t0 } or hermite(strictFrac-fracspace, edge.p0,edge.t0,edge.p1,edge.t1)
	local pPos = hermite(strictFrac, edge.p0,edge.t0,edge.p1,edge.t1)
	local rpos = nodeOrder == numberOfNodes and {p = edge.p1, t = edge.t1} or hermite(strictFrac+fracspace, edge.p0,edge.t0,edge.p1,edge.t1)
	local leftterrainHeight = th(lpos.p)
	local terrainHeight = th(pPos.p)
	local rightterrainHeight =	th(rpos.p)
	
	if checkBoxFollowTerrain:isSelected() then
		--lpos.p.z = leftterrainHeight
		--pPos.p.z = terrainHeight
		--rpos.p.z = rightterrainHeight
		lpos.p.z = context.actualHeights[nodeOrder-1]
		pPos.p.z = context.actualHeights[nodeOrder]
		rpos.p.z = context.actualHeights[nodeOrder+1]
	end
	
	
	if (nodeOrder == 1 or nodeOrder == numberOfNodes) and terrainHeight < 0 then
		--[[
		debuglog("Problem near connector underwater")
		for i =1, 10 do 
			local s = nodeOrder == 1 and -i or i
			local strictFrac2 =  strictFrac  + fracspace* (s/11)  
			pPos = hermite(strictFrac2, edge.p0,edge.t0,edge.p1,edge.t1)
			terrainHeight = api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(pPos.p.x,pPos.p.y))
			if terrainHeight >0 then 
				debuglog("Fixed Problem near connector underwater at ", strictFrac2, " instead of ", strictFrac)
				break
			end
	
		end	
		if  terrainHeight <0 then
			print("WARNING! Unable to find starting point for bridge")
		end]]--
		
	end
	
	local function calculateBridgeHeight(i)
		if context.bridgeOverTerrain or context.bridgeMaxHeight > maxbridgeHeight then
			trace("calculating bridge height",i,"using context.actualHeights[i]=",context.actualHeights[i])
			return context.actualHeights[i]
		end
		local maxHeight =  math.min(5*(context.bridgeLength-2)+minbridgeHeight, maxbridgeHeight)
	
		local imid = (context.bridgeLength/2)
		local x = imid-i+context.bridgeStart
		local minheight = x > 0 and math.max(context.bridgeStartHeight, minbridgeHeight) or math.max(context.bridgeEndHeight, minbridgeHeight)
		maxHeight = math.max(maxHeight,minheight) -- bridges to a high terrain point will be flat
		local a = (minheight - maxHeight)/imid^2
		local result = maxHeight+a*x^2
		trace("calculated bridge height at i=", i, " as ", result, " x=", x, " a=", a, " for bridgeLength=", context.bridgeLength, " start height ", context.bridgeStartHeight, " end height=", context.bridgeEndHeight)
		return result
	end
	

	local tunnelCandidate = isTunnelCandidateFn(nodeOrder)
	local needsBridge = isBridge(nodeOrder)

	if tunnelCandidate and allowTunnels:isSelected() then
		--lpos.p.z = context.tunnelHeights[nodeOrder]
		--pPos.p.z = context.tunnelHeights[nodeOrder]
		--rpos.p.z = context.tunnelHeights[nodeOrder]
	elseif needsBridge and allowBridges:isSelected() then
		lpos.p.z = calculateBridgeHeight(nodeOrder-1)
		pPos.p.z = calculateBridgeHeight(nodeOrder)
		rpos.p.z = calculateBridgeHeight(nodeOrder+1)
	end

	if nodeOrder == context.bridgeEnd then
		searchForBridges(nodeOrder+1) -- look for the next bridge
	end
	
	if nodeOrder == context.tunnelEnd then
		searchForTunnels(nodeOrder+1) -- look for the next tunnel
	end

	
	-- setup tangents begin
	lpos.t = (2*context.seglength)*vec3.normalize(lpos.t)
	lpos.t.z = 2*(pPos.p.z-lpos.p.z) --/context.seglength
	rpos.t = (2*context.seglength)*vec3.normalize(rpos.t)
	rpos.t.z =2*(rpos.p.z-pPos.p.z) --/context.seglength
	-- setup tangents end
	
	local treduce = 2 / numberOfNodes
	local newedge = {
			t0 = lpos.t,
			t1 = rpos.t,
			--t0 = treduce * lpos.t,
			--t1 = treduce * rpos.t,
			p0 = lpos.p,
			p1 = rpos.p,
	}
	--if tracelog then debugPrint({inputedge=edge, strictFrac=strictFrac, pPos=pPos, newedge=newedge}) end
	local b0, b1, b2, b3 = convertHermiteToBezier(newedge)
	
	local b1a, b2a, b3a, b4a, b5a, b1b, b2b, b3b, b4b, b5b, p0, p1, p2, p3, t0, t1, t2, t3, t
	local lowHalf = true
	local highHalf = true
	local ta = 0
	local tb = 1
	local minDistance = math.ceil(simpleLenght/3)
	local precision = 12 -- logarithmic; the precision doubles with every step
	local function  round(num, decimals)
	local mul = 10^(decimals or 0)
	return math.floor(num * mul + .5) / mul
	end
	local maxRecursions = round(math.log(context.seglength, 2), 0) + precision
	--local maxRecursions = precision
	local recursion = 1
	trace("Begin iteration, maxRecursions=",maxRecursions)
	repeat -- we divide it again and again to find a split point near our  position
		if highHalf then
			b1a, b2a, b3a, b4a, b5a = deCasteljau(b0, b1, b2, b3, ta)
		end
		if lowHalf then
			b1b, b2b, b3b, b4b, b5b = deCasteljau(b0, b1, b2, b3, tb)
		end
		if vec3.distance(pPos.p, b3a) < vec3.distance(pPos.p, b3b) then
			tb = tb - .5 * (tb - ta)
			lowHalf = true
			highHalf = false
		else
			ta = ta + .5 * (tb - ta)
			lowHalf = false
			highHalf = true
		end
		recursion = recursion + 1
	until recursion == maxRecursions
	
	local d = vec3.distance(pPos.p, b3a)
	if  d < minDistance then
		if d < vec3.distance(pPos.p, b3b) then
			p0, p1, t0, t1 = convertBezierToHermite(b0, b1a, b2a, b3a)
			p2, p3, t2, t3 = convertBezierToHermite(b3a, b4a, b5a, b3)
			t = ta
		else
			p0, p1, t0, t1 = convertBezierToHermite(b0, b1b, b2b, b3b)
			p2, p3, t2, t3 = convertBezierToHermite(b3b, b4b, b5b, b3)
			t = tb
		end
	else 
		print("WARNING!!! d>=mindistance ",d,minDistance, " maxRecursions=" , maxRecursions)
		debugPrint({inputedge=edge, strictFrac=strictFrac, pPos=pPos, newedge=newedge})
	end
	local valid = true
	
	if pPos.p.z ~= p1.z then
		trace("changing p1.z from ", p1.z, " to pPos.p.z=", pPos.p.z, " lpos.p.z=",lpos.p.z," rpos.p.z=",rpos.p.z," lpos.t.z=",lpos.t.z," rpos.t.z=",rpos.t.z," t1.z=",t1.z)
		p1.z = pPos.p.z
	end
	
	if checkBoxFollowTerrain:isSelected() then
		if tunnelCandidate and allowTunnels:isSelected() then

--			t1.z = 0
		else
	--		p1.z = api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(p1.x,p1.y))
			
		end
		
	end

	if needsBridge and not context.bridgeOverTerrain and not allowBridges:isSelected() then	
		valid = false
		p1 = oldNode and nodePos(oldNode) or p1
	end

	local newNode = api.type.NodeAndEntity.new()
	newNode.entity = oldNode and -oldNode or -nodeOrder
	local abort = false
	if not oldNode and nodeOrder < (numberOfNodes-3) and nodeOrder > 3 then
		local r = hypotlen(pPos.p, rpos.p)
		
		local nearbyNodes = game.interface.getEntities({ radius=r, pos= { p1.x, p1.y, p1.z, }}, {type="BASE_NODE", includeData=false})
		if #nearbyNodes > 0 then
			trace("search for nodes nearby radius ", r, " found")
			newNode.entity = nearbyNodes[1]
			abort = true
		end
	end
	
	-- final validation
	if needsBridge and p1.z < (context.terrainHeights[nodeOrder]+minBridgeHeightAboveGround) then
		trace("removing needsbridge",nodeOrder)
		needsBridge =false
	elseif p1.z > (context.terrainHeights[nodeOrder]+minbridgeHeight) and not needsBridge then  
		needsBridge = true
		trace("adding needsbridge",nodeOrder)
	elseif p1.z < (context.terrainHeights[nodeOrder]-minTunnelDepth) and not tunnelCandidate then
		tunnelCandidate = true
		trace("adding tunnelCandidate", nodeOrder)
	elseif tunnelCandidate and p1.z>= context.terrainHeights[nodeOrder] then
		tunnelCandidate = false
		trace("removing tunnelCandidate", nodeOrder)
	
	end
	local bridgeHeight
	if needsBridge then
		bridgeHeight = (context.bridgeStartHeight and context.bridgeEndHeight) and math.max(context.bridgeStartHeight, context.bridgeEndHeight) or p1.z
	end
	newNode.comp.position.x = p1.x
	newNode.comp.position.y = p1.y
	newNode.comp.position.z = p1.z

	trace("finished creating new node")
	--if tracelog then debugPrint( {  newnode = newNode.comp.position, calculatedNode = pPos, t0=t0, t1=t1, t2=t2,t3=t3, t=t}) end
	return {
	p1=p1,
	oldNode=oldNode,
	newNode=newNode,
	oldNodePos= oldNode and nodePos(oldNode) or nil,
	tunnelCandidate=tunnelCandidate,
	t0=t0,
	t1=t1,
	t2=t2, 
	t3=t3,
	t=t,
	valid= valid,
	needsBridge=needsBridge,
	terrainHeight = api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(p1.x,p1.y)),
	lastSplit = lastSplit,
	abort = abort,
	bridgeHeight = bridgeHeight
	}
end
				local function noJunctions(edge) 
					return #api.engine.system.streetSystem.getNode2SegmentMap()[edge.node0] == 2 and
					#api.engine.system.streetSystem.getNode2SegmentMap()[edge.node1] == 2
				end
				local function noJunctions2(edgeId)
					return  isCountry2(edgeId) and noJunctions(api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE))
				end
	
	local button4 = newButton(_('Undo'))
	local function toggleUndo() 
		button4:setEnabled(#lastResults>0)
	end
	toggleUndo()
	button4:onClick(function() 
		if #lastResults == 0 then 
			toggleUndo() 
			return 
		end
		table.insert(workItems, 
		function() 
			xpcall(
				function()
					local lastResult = table.remove(lastResults, #lastResults)
					toggleUndo() 
					if not lastResult then 
						workComplete = true
						return
					end
					local newProposal = api.type.SimpleProposal.new()
					for i, node in pairs(lastResult.addedNodes) do
						--newProposal.streetProposal.nodesToRemove[i]=node
					end
					local nodesToRemove = {}
					local seenNodes={}
					for i, seg in pairs(lastResult.addedSegments) do
						if isCountry2(seg) then
							trace("getting component for seg ", seg)
							local edge = api.engine.getComponent(seg, api.type.ComponentType.BASE_EDGE)
							for j, node in pairs({edge.node0, edge.node1}) do
								if seenNodes[node] then -- seen it twice - does not belong to another edge
									table.insert(nodesToRemove,node)
								else 
									seenNodes[node]=true
								end
							end						
							newProposal.streetProposal.edgesToRemove[1+#newProposal.streetProposal.edgesToRemove]=seg
						end
					end
					
					for i, node in pairs(nodesToRemove) do
						newProposal.streetProposal.nodesToRemove[i]=node
					end
					for i, construction in pairs(lastResult.resultEntities) do
						newProposal.constructionsToRemove[i]=construction
					end
					local context = api.type.Context.new()
					context.cleanupStreetGraph = false
					context.gatherBuildings = false
					context.player = game.interface.getPlayer()
					local build = api.cmd.make.buildProposal(newProposal, context, true)
					api.cmd.sendCommand(build, function(res, success) 
							debuglog(" attempt command result was", tostring(success))
							workComplete = true
					end)
				end,
			err)
		end
		)
		needsupdate = true

	end)
				
	button:onClick(function()
		local edges = {}
		local edgesBySpeedLimit = {}
		local edgesToProcess = {}
		local successCount = 0
		local failedCount = 0
		local speeds = {}
		
		xpcall(function() 
			doUpgrade(api.gui.comp.TextView.new(" "), function(edge) 
		
				if not edge.track and not edges[edge.id] then
					if noJunctions2(edge.id) then
						local found = speedthreashold3(edge.id)
						if found.result then 
							edges[edge.id]=edge
							local curSpeed = found.curSpeed
							while edgesBySpeedLimit[curSpeed] do
								curSpeed = curSpeed + 0.0000001
							end
							table.insert(speeds,curSpeed)
							edgesBySpeedLimit[curSpeed]=edge.id
							debuglog("found edge with id", edge.id)
						end
					end
				end
				return false
				end,
				function(entity) end)
			resultView:setText(#edges.._(' segments were found'))	
			debuglog(#edges, _(' segments were found'))
			table.sort(speeds)
			if tracelog then debugPrint({speeds=speeds, edgesBySpeedLimit=edgesBySpeedLimit, edges=edges}) end
			for index=1,#speeds do
				local edgeId = edgesBySpeedLimit[speeds[index]] -- ugh!
				debuglog("start of main iteration with edgeid=", edgeId)
				if edgesToProcess[edgeId] then
					debuglog("skipping loop iteration")
					goto continue
				end
				
				local edge = edges[edgeId]
				local function check(edgeId)
					return not edgesToProcess[edgeId] and noJunctions2(edgeId)
				end
	
				
				local leftsegs = api.engine.system.streetSystem.getNode2SegmentMap()[edge.node0]
				local rightsegs = api.engine.system.streetSystem.getNode2SegmentMap()[edge.node1]
				debuglog("#leftsegs =", #leftsegs, " and #rightsegs =", #rightsegs)
				if noJunctions(edge)  then
					local nodesToRemoveSet ={}  
					nodesToRemoveSet[edge.node0]=true
					nodesToRemoveSet[edge.node1]=true
					local edgestoChangeSet = {}
					local function findOtherSeg(segs)
						for k,v in pairs(segs) do 
							trace("inspecting k,v", k, " ", v, " on segs")
							if not edgestoChangeSet[v] then
								edgestoChangeSet[v]=true
								return v 
							end
						end
					end
					edgestoChangeSet[edge.id] = true
					
					local function findLeftSeg(edge) 
						return findOtherSeg(api.engine.system.streetSystem.getNode2SegmentMap()[edge.node0])
					end
					
					local function findRightSeg(edge) 
						return findOtherSeg(api.engine.system.streetSystem.getNode2SegmentMap()[edge.node1])
					end
					
					--local leftseg = leftsegs[1] == edge.id and leftsegs[2] or leftsegs[1]
					--local rightseg = rightsegs[1] == edge.id and rightsegs[2] or rightsegs[1]
					-- grr
					local leftseg =  findLeftSeg(edge) 
					local rightseg = findRightSeg(edge) 
					local edgesToChange = {edge.id  }
					while speedthreashold2(leftseg) and noJunctions2(leftseg) and #edgesToChange <=segmentLimit/2 do
						
						local leftsegment = api.engine.getComponent(leftseg, api.type.ComponentType.BASE_EDGE)
						local leftsegcandidate = findLeftSeg(leftsegment) 
						if leftsegcandidate == nil then
							leftsegcandidate = findRightSeg(leftsegment) 
							if leftsegcandidate== nil then
								print("WARNING!!! LEFTSEGCANDIDATE WAS NIL")
							end
							if check(leftsegcandidate)   then
								nodesToRemoveSet[leftsegment.node1]=true
							end
						elseif check(leftsegcandidate)  then 
							nodesToRemoveSet[leftsegment.node0]=true
						end
						if not check(leftsegcandidate) then 
							break
						end
						table.insert(edgesToChange, 1, leftseg)
						leftseg=leftsegcandidate
					end
					while speedthreashold2(rightseg) and noJunctions2(rightseg) and #edgesToChange <=segmentLimit do
						 
						local rightsegment = api.engine.getComponent(rightseg, api.type.ComponentType.BASE_EDGE)
						local rightsegcandidate = findRightSeg(rightsegment) 
						if rightsegcandidate == nil then
							rightsegcandidate = findLeftSeg(rightsegment) 
							if check(rightsegcandidate)  then
								nodesToRemoveSet[rightsegment.node0]=true
							end
						elseif check(rightsegcandidate)   then 
							nodesToRemoveSet[rightsegment.node1]=true
						end
						if not check(rightsegcandidate)   then
							break
						end
						table.insert(edgesToChange,  rightseg)
						rightseg=rightsegcandidate
					end
		
					local nodesToRemove = { }
					for node, bool in pairs(nodesToRemoveSet) do
						table.insert(nodesToRemove, node)
					end
					if not edgesToProcess[leftseg] and not edgesToProcess[rightseg] then 
						
						table.insert(edgesToChange, 1, leftseg)
						table.insert(edgesToChange, rightseg)
						debuglog("setting up edge ", edge.id)
						local leftsegment = api.engine.getComponent(leftseg, api.type.ComponentType.BASE_EDGE)
						local rightsegment = api.engine.getComponent(rightseg, api.type.ComponentType.BASE_EDGE)
						local frozenNodes = {  }
					
						for _, node in pairs({leftsegment.node0, rightsegment.node0, leftsegment.node1, rightsegment.node1}) do
							if not nodesToRemoveSet[node] then
								frozenNodes[node]=true
							end
						end
						local leftnode = frozenNodes[leftsegment.node0] and leftsegment.node0 or leftsegment.node1
						local rightnode = frozenNodes[rightsegment.node0] and rightsegment.node0 or rightsegment.node1
						local  newProposal  = api.type.SimpleProposal.new()
						--local calc = getEdgeBasics(edgeId, 0) 
						local lf = leftnode == leftsegment.node0 and 1 or -1
						local lefttangent = leftnode == leftsegment.node0 and leftsegment.tangent0 or leftsegment.tangent1
						local rf = rightnode == rightsegment.node1 and 1 or -1
						local righttangent = rightnode == rightsegment.node1 and rightsegment.tangent1 or rightsegment.tangent0
						local dummyEdge = {
								t0 = lf*(#nodesToRemove+1)*v3(lefttangent),
								t1 = rf*(#nodesToRemove+1)*v3(righttangent),
								p0 = nodePos(leftnode),
								p1 = nodePos(rightnode),
						}
						local splits = {}
						--if tracelog then debugPrint(edge) end
					
					
						local nodeNorderLoopkup = {}
						local nodesInOrder = {}
						for i, edgeId in pairs(edgesToChange) do 
							local edge =  api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE)
							if not frozenNodes[edge.node0] and not nodeNorderLoopkup[edge.node0] then
								nodeNorderLoopkup[edge.node0]=i
								table.insert(nodesInOrder, edge.node0)
							end
							if not frozenNodes[edge.node1] and not nodeNorderLoopkup[edge.node1] then
								nodeNorderLoopkup[edge.node1]=i
								table.insert(nodesInOrder, edge.node1)
							end
						end
						
						if tracelog then debugPrint({nodeordering=nodeordering, nodeNorderLoopkup=nodeNorderLoopkup}) end
						
						trace("about to create splits")
						local lastSplit = nil
						local context = { }
						for i, node in pairs(nodesInOrder) do 
							lastSplit = recursiveSplitter(dummyEdge, node, #nodesToRemove, nodeNorderLoopkup[node], lastSplit, context)
							table.insert(splits, lastSplit)
						end
						local splitMap = {}
						--if tracelog then debugPrint(splits) end
						trace("splits created, attempting to set nodes on new proposal")
						for i, split in pairs(splits) do 
							splitMap[split.oldNode]=split
						end
						local highestFrozen  = math.max(nodePos(leftnode).z,nodePos(rightnode).z)
						--[[if checkBoxFollowTerrain:isSelected() then
							for i = 2, #nodesInOrder-1 do
								local splitBefore = splitMap[nodesInOrder[i-1] ]
								local splitMiddle = splitMap[nodesInOrder[i] ]
								local splitAfter = splitMap[nodesInOrder[i+1] ]
								local m0 = splitMiddle.p1.z-splitBefore.p1.z
								local m1 = splitAfter.p1.z-splitMiddle.p1.z
								local p0 = splitBefore.p1.z 
								local p1 = splitAfter.p1.z
								local t = 0.5
								-- cubic hermite derivative
								local tz = m0 * (3*t^2 - 4*t + 1) + m1 * (3*t - 2) * t + 6 * (t - 1) * t * (p0 - p1)
								local leftGrad = m0/hypotlen(splitMiddle.p1,splitBefore.p1)
								local rightGrad = m1/hypotlen(splitAfter.p1,splitMiddle.p1)
								trace("tangent before ", splitMiddle.t1.z, " tangent after ", tz,  " leftGrad=", leftGrad, " rightGrad=", rightGrad)
								--splitMiddle.t1.z=tz
								if (math.abs(leftGrad) > 0.05 or math.abs(rightGrad) > 0.05) and (splitMiddle.p1.z - highestFrozen)>15 or (splitMiddle.p1.z - highestFrozen)>20 then
									trace("tunnel candidate found on node ", splitMiddle.oldNode)
									splitMiddle.tunnelCandidate=true
								end
							end
						end--]]
						
						trace("proposal setup, about to enter edge loop")
						--if tracelog then debugPrint(splitMap) end
						--if tracelog then debugPrint({frozenNodes=frozenNodes}) end
						
						local lastNode = leftnode
						local lastz = nodePos(lastNode).z
						for i, edgeid in pairs(edgesToChange) do
							trace("begin loop ", i)
							local isReversed = false
							local entity = api.type.SegmentAndEntity.new()
							entity.entity = -edgeid
							entity.playerOwned =api.engine.getComponent(edgeid, api.type.ComponentType.PLAYER_OWNED)
							entity.comp = api.engine.getComponent(edgeid, api.type.ComponentType.BASE_EDGE)
							entity.type = 0
							entity.streetEdge = api.engine.getComponent(edgeid, api.type.ComponentType.BASE_EDGE_STREET)
							if i == 1  then
								isReversed = entity.comp.node1 == leftnode 
							elseif i == #edgesToChange   then
								isReversed = entity.comp.node0 == rightnode
							else
								isReversed = entity.comp.node1 == lastNode
								assert(entity.comp.node0 ==lastNode or entity.comp.node1 ==lastNode, "should have continuous nodes") 
							end
							lastNode = isReversed and entity.comp.node0 or entity.comp.node1
							
							
							
							local node0 = nodePos(entity.comp.node0)
							local node1 = nodePos(entity.comp.node1)
							
							if i>1 and i<#edgesToChange and (allowBridges:isSelected() or allowTunnels:isSelected()) then
								local split0 = splitMap[entity.comp.node0]
								local split1 = splitMap[entity.comp.node1]
								if entity.type == 2 then 
									entity.type = 0 -- clear previous tunnel property
								end
								if  allowTunnels:isSelected() then 
									if split0.tunnelCandidate and split1.tunnelCandidate then
										local z = math.min(lastz, split0.terrainHeight-10, split1.terrainHeight-10)
										trace("setting z for nodes ", entity.comp.node0, " ", entity.comp.node1, " to ", z)
										split0.newNode.comp.position.z = z
										split1.newNode.comp.position.z = z
										split0.t1.z=0
										split1.t1.z=0
										entity.comp.type=2 -- tunnel
										entity.comp.typeIndex=1 -- only one type of tunnel
									elseif split0.tunnelCandidate then
										-- level off approaches 
										split1.newNode.comp.position.z = math.min(split1.newNode.comp.position.z, split0.newNode.comp.position.z, lastz)
										split1.t1.z=0
									elseif split1.tunnelCandidate then
										split0.newNode.comp.position.z = math.min(split1.newNode.comp.position.z, split0.newNode.comp.position.z, lastz)
										split0.t1.z=0
									end
								end
								if (split0.p1.z < 0 or split1.p1.z < 0) and allowBridges:isSelected() then 
									local height = 10
									split0.newNode.comp.position.z = split0.p1.z < 0 and height or height+split0.p1.z
									split1.newNode.comp.position.z = split1.p1.z < 0 and height or height+split1.p1.z
									split0.t1.z=0
									split1.t1.z=0
									entity.comp.type=1 -- bridge
									entity.comp.typeIndex = findBridgeType()
								end
							end
							
							lastz = splitMap[lastNode] and splitMap[lastNode].newNode.comp.position.z or nodePos(lastNode).z
							local function setTangent(tangent, t)
								local f = isReversed and -1 or 1
								tangent.x = f * t.x 
								tangent.y = f * t.y
								tangent.z = f * t.z
							end
							if not frozenNodes[entity.comp.node0] then
								trace("start altering node0", entity.comp.node0)
								local split = splitMap[entity.comp.node0]
								entity.comp.node0 = split.newNode.entity
								if tracelog then debugPrint({ tangent0Before=entity.comp.tangent0}) end
								if split.valid then
									setTangent(entity.comp.tangent0,split.t1)
								end
								if tracelog then debugPrint({ tangent0After=entity.comp.tangent0}) end
								trace("finish altering node0")
								node0 = split.p1
							end
							if not frozenNodes[entity.comp.node1] then
								trace("start altering node1 ", entity.comp.node1)
								local split = splitMap[entity.comp.node1]
								entity.comp.node1 = split.newNode.entity
								if tracelog then debugPrint({ tangent1Before=entity.comp.tangent1}) end
								if split.valid then
									setTangent(entity.comp.tangent1,split.t1)
								end
								if tracelog then debugPrint({ tangent1After=entity.comp.tangent1}) end
								trace("finish altering node1")
								node1 = split.p1
							end
							
							trace("Inspecting tangents")
							--local function t(t) return v3(t.x, t.y, t.z) end
							local t0 = v3(entity.comp.tangent0)
							local t1 = v3(entity.comp.tangent1)
							trace("calculating length")
							local length = calcEdgeLength(node0, node1, t0 ,t1 )
							-- hmm https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.104.1622&rep=rep1&type=pdf
							local simpleLenght = hypotlen(node0, node1)
							local factor = length /simpleLenght
							local idealfactor = math.sqrt(2) -- massive simplification
							local scale = factor / idealfactor
							trace("length=", length, " simpleLenght=", simpleLenght, " factor=", factor, " scale=", scale)
							if scale > 1 then
								debuglog("Reducing scale by ", (1/scale))
								t0 =   (1/scale) * t0
								t1 =   (1/scale) * t1
								
							end
							local t0length = hypot(t0.x,t0.y)
							local t1length = hypot(t1.x,t1.y)
							trace("before t0length=", t0length, " t1length=", t1length, " computed=", length)
							if t0length > 1.5*length then
								debuglog("reducing t0")
								t0 = (1.5*length/t0length) * t0
							end
							if t1length > 1.5*length then
								debuglog("reducing t1")
								t1 = (1.5*length/t1length) * t1
							end
							local t0length = hypot(t0.x,t0.y)
							local t1length = hypot(t1.x,t1.y)
							setTangent(entity.comp.tangent0, t0)
							setTangent(entity.comp.tangent1, t1)
							trace("after t0length=", t0length, " t1length=", t1length)
							if isReversed then
								trace("swapping nodes and tangents")
								local temp = entity.comp.node0
								entity.comp.node0 = entity.comp.node1
								entity.comp.node1 = temp
								setTangent(entity.comp.tangent0, t1)
								setTangent(entity.comp.tangent1, t0)
							end
							
							 
							
							newProposal.streetProposal.edgesToRemove[i]  = edgeid
							newProposal.streetProposal.edgesToAdd[i] = entity
							edgesToProcess[edgeid]=true
							trace("end loop ", i, " edgeid ", edgeid, " isReversed=", tostring(isReversed), " lastNode=", lastNode)
						end
						trace("loop complete")
						for i, split in pairs(splits) do 
							newProposal.streetProposal.nodesToRemove[i]=split.oldNode
							newProposal.streetProposal.nodesToAdd[i]=split.newNode
						end
						--if tracelog then debugPrint(newProposal) end
						
						local context = api.type.Context.new()
						context.cleanupStreetGraph = cleanupStreetGraph:isSelected()
						context.checkTerrainAlignment = checkBoxAlignTerrain:isSelected()
						context.gatherBuildings = gatherBuildings:isSelected() 
						context.player = game.interface.getPlayer()
						trace("About to build proposal")
						local build = api.cmd.make.buildProposal(newProposal, context, false)
						--if tracelog then debugPrint(build) end
						table.insert(workItems, function()
							trace("About to sent command")
							api.cmd.sendCommand(build, function(res, success) 
								debuglog(" attempt command result was"..tostring(success))
								if success then 
								--	failedCount = failedCount - 1
									successCount= successCount + 1
								else	
									failedCount = failedCount + 1
									--if debuglog then debugPrint(res) end
									debugPrint(res.resultProposalData.errorState)
								end
								--updateView()
								resultView:setText(successCount.._(' segments successfully altered.')..#workItems.._(' remaining ')..failedCount.._(' failed to upgrade'))
								workComplete = true
							end)
						end)
						needsupdate = true
					end
				end
			::continue::
			end
		end,err)

		end)

	local function findUrbanStreetsForTown(town,radius) 
		-- example:
		--[[
			 counts = { },
			id = 14882,
			lu2cargoInfo = { },
			name = "Davao City",
			position = { 2088, 1708, 2.0999984741211, },
			townDestCounts = { },
			type = "TOWN",
			useLinesCounts = { },
			useLinesPercentage = -1,
		--]]
		local result = {} 
		local edges = game.interface.getEntities({ radius=radius, pos=town.position}, {type="BASE_EDGE", includeData=true})
		for i, edge in pairs(edges) do 
			if not edge.track and isTown(edge.id) then 
				table.insert(result,edge)
			end
		end
		return result
	end
	
	
	
	local function isDeadEnd(node)
		local edges = api.engine.system.streetSystem.getNode2StreetEdgeMap()[node]
		if #edges~=1 then 
			return false
		end
		local edgeId = edges:at(1)
		local edge = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE )
		--debugPrint({edge = edge})
		local tangent = edge.node0 == node and edge.tangent0 or edge.tangent1
		-- walk in the direction to see if we hit the sea
		local clearLength = edge.node0 == node and -50 or 50
		local location = vec2.add(nodePos(node), vec2.mul(clearLength, vec2.normalize(vec2.new(tangent.x, tangent.y))))
		local result =  api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(location.x,location.y)) >=0
		if not result then 
			debuglog("rejected node ", node, " because it is too close to the sea ", location.x, ", ", location.y)
		end
		return result
		
	end
	
	local function findDeadEndNodes(town, radius) 
		local result = {}
		for edgeId, edge in pairs(findUrbanStreetsForTown(town,radius)) do 
			if isDeadEnd(edge.node0) then
				result[edge.node0]=edge.node0pos
			elseif isDeadEnd(edge.node1) then
				result[edge.node1]=edge.node1pos
			end
		end
		return result
	end
	local function findDeadEndNodesWithinAngel(town, radius, angel, vector) 
		local result = {}
		local function tangentWithinRange(tangent)
			local v2tangent = vec2.new(tangent[1],tangent[2])
			--debugPrint({v2tangent=v2tangent})
			local measuredAngel = vec2.angle(v2tangent,vector)
			--trace("comparing ",math.deg(measuredAngel)," with ",angel)
			return measuredAngel <=math.rad(angel)
		end
		for edgeId, edge in pairs(findUrbanStreetsForTown(town,radius)) do 
			if isDeadEnd(edge.node0) and tangentWithinRange(edge.node0tangent) then
				result[edge.node0]=edge.node0pos
			elseif isDeadEnd(edge.node1)and tangentWithinRange(edge.node1tangent)  then
				result[edge.node1]=edge.node1pos
			end
		end
		return result
	end

	
	local successCount =0
	local failedCount = 0
	
	local function addUndo(res) 
		local addedNodes = {}
				local addedSegments = {}
				--for i, node in pairs(res.proposal.proposal.addedNodes) do
				--	table.insert(addedNodes, node.entity)
				--end
				local alreadySeen = {}
				if #res.resultEntities == 0 then
					for i, tn in pairs(res.resultProposalData.entity2tn) do
						if #tn.nodes > 0 then
							table.insert(addedNodes, i)
						else 
							table.insert(addedSegments, i)
						end
					--[[	for j, tn in pairs(seg.edges) do
							for k = 1, 2 do
								local node = tn.conns[k].entity
								if not alreadySeen[node] then 
									alreadySeen[node]=true
									table.insert(addedNodes, node)
								end
							end
						end]]--
					end
				end
				table.insert(lastResults, { addedNodes = addedNodes, addedSegments = addedSegments, resultEntities=res.resultEntities})
				toggleUndo()
	end
	
	local function findShortestDistanceNodePair(leftNodes, rightNodes) 
		if not leftNodes or not rightNodes then
			return
		end
		local dists = {}
		local dists2NodePairs = {} 
		
		for nodeId, nodepos in pairs(leftNodes) do 
			for nodeId2, nodepos2 in pairs(rightNodes) do -- hmm quadratic but dead ends probably grow like log(n)
				local dist = hypotlen2(nodepos, nodepos2)
				table.insert(dists, dist) 
				dists2NodePairs[dist]= { nodeId, nodeId2, dist } 
			end
		end
		if #dists == 0 then
			debuglog("exiting early, no node pairs found")
			return
		end
		
		table.sort(dists)
		local shortest = dists[1]

		trace("shortest node dist was ", shortest)
		return dists2NodePairs[shortest]
	end
			local function setTangent(tangent, t) -- because tangent is mysterious "userdata", can't give it a vec3
			tangent.x = t.x
			tangent.y = t.y
			tangent.z = t.z
		end
	local function connectTowns2(nodepair, isTrack, node2SegMap)
		if isTrack then 
			maxGradient = math.min(maxGradient , 7)
		end
		local shortest = nodepair[3]

		--local targetSeglenth = 90
		local nodecount = math.floor(shortest/targetSeglenth)
		if tracelog then debugPrint({nodepair=nodepair}) end
		local leftnode = nodepair[1]
		local rightnode = nodepair[2]
		

		local leftEdgeId = node2SegMap[leftnode]
		local rightEdgeId = node2SegMap[rightnode]
		--local leftEdgeId = api.engine.system.streetSystem.getNode2StreetEdgeMap()[leftnode]:at(1) -- note second table is C Vector
		--local rightEdgeId = api.engine.system.streetSystem.getNode2StreetEdgeMap()[rightnode]:at(1)
		local leftEdge = api.engine.getComponent(leftEdgeId, api.type.ComponentType.BASE_EDGE)
		local rightEdge = api.engine.getComponent(rightEdgeId, api.type.ComponentType.BASE_EDGE)
		local seglenght = shortest / (1 + nodecount) 
		local lf = leftnode == leftEdge.node1 and seglenght or -seglenght
		local lefttangent = leftnode == leftEdge.node0 and leftEdge.tangent0 or leftEdge.tangent1
		local rf = rightnode == rightEdge.node0 and seglenght or -seglenght
		local righttangent = rightnode == rightEdge.node1 and rightEdge.tangent1 or rightEdge.tangent0
		
	
		

	
		lefttangent = lf*vec3.normalize(v3(lefttangent))
		righttangent = rf*vec3.normalize(v3(righttangent))
		
		local leftNodePos = nodePos(leftnode)
		local rightNodePos =nodePos(rightnode)
		
		local straightvec = vec2.sub(rightNodePos,leftNodePos)
		local leftangle = math.deg(vec2.angle(straightvec, lefttangent))
		local rightangle = math.deg(vec2.angle(straightvec, righttangent))
		trace("leftangle=", leftangle, " rightangle=", rightangle, " while inspecting ", straightvec.x, ",", straightvec.y, " against righttangent ", righttangent.x, ",", righttangent.y, " xyAngle=", vec3.xyAngle(straightvec), " righttangentXyangel=", vec3.xyAngle(righttangent), " right rot angle = ",  math.deg(vec2.angle(vec2.rotate90(straightvec),righttangent)), " rightrot angel other=",  math.deg(vec2.angle(straightvec,vec2.rotate90(righttangent))) )
		
		local function initSegmentAndEntity() 
			local entity = api.type.SegmentAndEntity.new()
			entity.type= isTrack and 1 or 0
			if isTrack then
				entity.trackEdge.trackType = api.res.trackTypeRep.find("standard.lua")
				entity.playerOwned = game.interface.getPlayer()
			else 
				entity.streetEdge.streetType = lookup1[1+combobox:getCurrentIndex()]
			end
			return entity
		end
		
		local nodesToAdd = {}
		local edgesToAdd = {}
		
		local function setBridge(entity, split)
			if allowBridges:isSelected() then
				entity.comp.type = 1 -- brdige
				entity.comp.typeIndex = findBridgeType(split)
				return true
			end
		end
		
		local function setTunnel(entity)
			if  allowTunnels:isSelected() then
				entity.comp.type = 2 -- tunnel
				entity.comp.typeIndex = 1 -- only 1 tunnel type
				return true
			end
		end
		
		local lefttunnelstart = false
		local righttunnelend = false
		if math.abs(rightangle) > threasholdAngle then 
			local newAngle = math.huge
			local corrected
			local loopcount = 0
			while(math.abs(newAngle)>=math.abs(rightangle+0.01)) do -- I expect there is a mathematical way of doing this without a search but I am not smart enough to figure it out
				local delta=  rightangle-threasholdAngle
				local factor0 = delta > threasholdAngle and 1 or -1 
				local factor = loopcount % 2 ==0 and factor0 or -factor0 
				local correctionAngle = math.rad(factor * delta)+math.floor(loopcount/2) * math.rad(90)
				trace("correcting right hand segmen by ", math.deg(correctionAngle))
				local nrml = vec3.normalize(righttangent)
				-- https://stackoverflow.com/questions/4780119/2d-euclidean-vector-rotations
				corrected = targetSeglenth *
				vec3.new(
					nrml.x * math.cos(correctionAngle) - nrml.y * math.sin(correctionAngle),
					nrml.x * math.sin(correctionAngle) + nrml.y * math.cos(correctionAngle),
					0 -- z
				)
				newAngle =math.deg(vec2.angle(straightvec, corrected))
				local angelToTheRightTangent = math.deg(vec2.angle(corrected, righttangent))
				trace("rightangle new angel is ",newAngle, " angelToTheRightTangent=", angelToTheRightTangent )
				loopcount = loopcount + 1
				if loopcount > 9 then
				 if newAngle > rightangle then
						print("WARNING!!! I made the angel worse!!! at ")
					end
					break
				end
			end
			local originalz = rightNodePos.z
			rightNodePos =  rightNodePos - 0.5*corrected-0.5*righttangent -- this is probably very cude
			if checkBoxFollowTerrain:isSelected() then
				rightNodePos.z =  th(rightNodePos)
				local rightgrad = 100*((rightNodePos.z-originalz )/ targetSeglenth)
				if rightgrad >= maxGradient and allowTunnels:isSelected() then
					rightNodePos.z = originalz
					righttunnelend = true
				end
				if rightgrad > maxGradient then
					local oldVal = rightNodePos.z
					trace("clamping right initial gradient")
					rightNodePos.z = originalz+((maxGradient/100)*targetSeglenth)
					trace("clamping right initial gradient from ",oldVal," to ",rightNodePos.z)
				end
			end
			if allowBridges:isSelected() then
				local extrapos = -targetSeglenth * vec3.normalize(corrected) + rightNodePos
				local extraposhalf = -0.5*targetSeglenth * vec3.normalize(corrected) + rightNodePos
				if th(extrapos) <0 or th(extraposhalf) < 0  then
						rightNodePos.z = rightNodePos.z + 5 -- give it a bit of a ramp to make it easier to connect 
						corrected.z = corrected.z - 5
				end
			end
			local newNode =  api.type.NodeAndEntity.new()
			newNode.entity = -3*nodecount
			newNode.comp.position.x = rightNodePos.x 
			newNode.comp.position.y = rightNodePos.y
			newNode.comp.position.z = rightNodePos.z 
			local entity = initSegmentAndEntity()
			entity.entity = -3*nodecount-1
		
			entity.comp.node0 = newNode.entity
			
			entity.comp.node1 = rightnode
			if righttunnelend then
				setTunnel(entity)
			end
			setTangent(entity.comp.tangent0, corrected)
			setTangent(entity.comp.tangent1, righttangent)
			righttangent = corrected
			rightnode = newNode.entity
			table.insert(edgesToAdd, entity)
			table.insert(nodesToAdd, newNode)
		end	

		if math.abs(leftangle) > threasholdAngle then 
			local newAngle = math.huge
			local corrected
			local loopcount = 0
			while(math.abs(newAngle)>=math.abs(leftangle+0.01)) do
				local delta=  leftangle-threasholdAngle
				local factor0 = delta > threasholdAngle and 1 or -1 
				local factor = loopcount % 2 ==0 and factor0 or -factor0
				--local correctionAngle = math.rad(threasholdAngle + factor * delta)+ math.floor(loopcount/2)* math.rad(90)
				local correctionAngle = math.rad(factor * delta)+ math.floor(loopcount/2)* math.rad(90)
				trace("math.deg(vec2.angle(vec2.rotate90(straightvec),lefttangent))=",math.deg(vec2.angle(vec2.rotate90(straightvec),lefttangent))," vec2.angle(straightvec),vec2.rotate90(lefttangent))=",math.deg(vec2.angle(straightvec,vec2.rotate90(lefttangent))))
				--if math.deg(vec2.angle(vec2.rotate90(straightvec),lefttangent)) < leftangle then
				--	trace("correcting the ",math.deg(correctionAngle),"by adding 180 deg")
				--	correctionAngle = correctionAngle + math.rad(180)
				--else
				--if  math.deg(vec2.angle(vec2.rotate90(straightvec),lefttangent)) > 90 then
				--	trace("correcting the ",math.deg(correctionAngle),"by adding 90 deg")
					 
				--end
				trace("correcting left hand segment by ", math.deg(correctionAngle))
				local nrml = vec3.normalize(lefttangent)
				-- https://stackoverflow.com/questions/4780119/2d-euclidean-vector-rotations
				corrected = targetSeglenth *
				vec3.new(
					nrml.x * math.cos(correctionAngle) - nrml.y * math.sin(correctionAngle),
					nrml.x * math.sin(correctionAngle) + nrml.y * math.cos(correctionAngle),
					0 -- z
				)
				 newAngle = math.deg(vec2.angle(straightvec, corrected))
				local angelToTheLeftTangent = math.deg(vec2.angle(corrected, lefttangent))
				trace("leftangle new angel is ",newAngle, " angelToTheLeftTangent=", angelToTheLeftTangent, " factor0=",factor0," factor=",factor, "loopcount % 2= ", loopcount % 2 ," delta=",delta  )			
				loopcount = loopcount + 1
				if loopcount > 9 then
				 if newAngle > leftangle then
						print("WARNING!!! I made the angel worse!!! at ")
					end
					break
				end
			end
			local originalz = leftNodePos.z
			leftNodePos =  leftNodePos + 0.5*corrected+0.5*lefttangent -- this is probably very cude
			if checkBoxFollowTerrain:isSelected() then
				leftNodePos.z =  api.engine.terrain.getBaseHeightAt(api.type.Vec2f.new(leftNodePos.x,leftNodePos.y))
				local leftgrad = 100*((leftNodePos.z-originalz)/ targetSeglenth)
				if leftgrad >= maxGradient and allowTunnels:isSelected() then
					leftNodePos.z = originalz
					lefttunnelstart = true
				end
				if leftgrad < -maxGradient then
					local oldVal = leftNodePos.z
					trace("clamping left initial gradient")
					leftNodePos.z = originalz-((maxGradient/100)*targetSeglenth)
					trace("clamping left initial gradient from ",oldVal," to ",leftNodePos.z)
				end
			end
			if allowBridges:isSelected() then
				local extrapos = targetSeglenth * vec3.normalize(corrected) + leftNodePos
				local extraposhalf = 0.5*targetSeglenth * vec3.normalize(corrected) + leftNodePos
				trace("checking terrian hieght at ",extrapos.x,extrapos.y)
				if th(extrapos) <0 or th(extraposhalf) < 0 then
					trace("giving leftNodePos a boost")
					leftNodePos.z = leftNodePos.z + 5 -- give it a bit of a ramp to make it easier to connect 
					corrected.z = corrected.z + 5
				end
			end
			local newNode =  api.type.NodeAndEntity.new()
			newNode.entity = -4*nodecount
			newNode.comp.position.x = leftNodePos.x 
			newNode.comp.position.y = leftNodePos.y
			newNode.comp.position.z = leftNodePos.z 
			local entity = initSegmentAndEntity() 
			entity.entity = -4*nodecount-1
			 
			entity.comp.node1 = newNode.entity
			
			entity.comp.node0 = leftnode
			if lefttunnelstart then
				setTunnel(entity)
			end
			setTangent(entity.comp.tangent1, corrected)
			setTangent(entity.comp.tangent0, lefttangent)
			lefttangent = corrected
			leftnode = newNode.entity
			table.insert(edgesToAdd, entity)
			table.insert(nodesToAdd, newNode)
		end		
		
		local dummyEdge = {
				t0 = (seglenght*(nodecount+1))*vec3.normalize(lefttangent),
				t1 = (seglenght*(nodecount+1))*vec3.normalize(righttangent),
				p0 = leftNodePos,
				p1 = rightNodePos,
		}
		if tracelog then debugPrint({dummyEdge=dummyEdge}) end
	
		local  newProposal  = api.type.SimpleProposal.new()
		local prevnode = leftnode
		local prevtangent = lefttangent
		local prevSplit = nil

		local splits = {}
		local abort = false
		local context = {} 
		for i=1, nodecount do 
			local split = recursiveSplitter(dummyEdge, nil,nodecount, i, prevSplit, context)
			prevSplit = split
			table.insert(splits, split)
			if split.abort and not allowIntersections:isSelected() then 
				connectTowns(orderedCityPairs, index+1)
				
				nodecount = i
				abort = true
				break
			end
			
		end
		if abort then 
			workComplete = true
			return
		end
		

		
		
		
		for i=1, nodecount do
			local split = splits[i]
			local prevSplit = i > 1 and splits[i-1] or nil
			--if tracelog then debugPrint({i=i, prevnode=prevnode, leftnode=leftnode, split=split}) end
			local entity = initSegmentAndEntity() 
			local lefttunnel = prevSplit and prevSplit.tunnelCandidate or i==1 and lefttunnelstart
			if lefttunnel and split.tunnelCandidate then 
				setTunnel(entity)
			elseif allowTunnels:isSelected() and prevSplit and split.tunnelCandidate then
				--local oldPosz = prevSplit.newNode.comp.position.z 
				--prevSplit.newNode.comp.position.z = math.min(split.newNode.comp.position.z, oldPosz)
			end
			if  prevSplit and prevSplit.needsBridge and split.needsBridge
				or prevSplit and prevSplit.terrainHeight < 0 or split.terrainHeight<0	then
				setBridge(entity, split)
			end
			
			
			entity.entity = -i-nodecount
			entity.comp.node0 = prevnode
			
			entity.comp.node1 = split.newNode.entity
			setTangent(entity.comp.tangent0, prevtangent)
			setTangent(entity.comp.tangent1, split.t1)
			table.insert(edgesToAdd, entity)
			if split.newNode.entity < 0 then
				table.insert(nodesToAdd, split.newNode)
			end
			prevnode = split.newNode.entity
			prevtangent = split.t1
			
		end
		
		if not abort then
			-- need to add final segment
			local entity = initSegmentAndEntity() 
			
			
			entity.entity = -1-2*nodecount
			setTangent(entity.comp.tangent0, prevtangent)
			setTangent(entity.comp.tangent1, righttangent)
			entity.comp.node0 = prevnode
			entity.comp.node1 = rightnode
			local prevSplit = splits[nodecount]
			if prevSplit and prevSplit.tunnelCandidate then
				setTunnel(entity)
			elseif prevSplit and prevSplit.needsBridge then
				if setBridge(entity, prevSplit) and rightnode < 0 then
					nodesToAdd[1].comp.position.z = nodesToAdd[1].comp.position.z + 5
				end
			end
			table.insert(edgesToAdd, entity)
		end
		
		for i, node in pairs(nodesToAdd) do -- need a seperate loop as it appears the node data gets copied when set on the proposal
			newProposal.streetProposal.nodesToAdd[i]=node
			--if i == 1 then break end
		end
		for i, edge in pairs(edgesToAdd) do
			newProposal.streetProposal.edgesToAdd[i]=edge
		--	if i == 1 then break end
		end

		-- newConstruction.params.seed=1
		--[[
		newConstruction.params = {
		  autoRoofs = 1,
          buildingSize = 4,
          buildingStyle = 3,
          catenary = 1,
          length = 2,
		  paramX = 0,
          paramY = 0,
          seed = 0,
          trackType = 0,
          tracks = 0,
          year = 1925,
		  modules= {
        [3400020] = {
          metadata = {
            era = 1,
            level = 1,
            span = { 1, 2, },
          },
          name = "station/rail/modular_station/main_building_1_era_b.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [7400000] = {
          metadata = {
            passenger_platform = true,
            platform = true,
          },
          name = "station/rail/modular_station/platform_passenger_era_b.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [7400010] = {
          metadata = {
            passenger_platform = true,
            platform = true,
          },
          name = "station/rail/modular_station/platform_passenger_era_b.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [8401000] = {
          metadata = {
            track = true,
          },
          name = "station/rail/modular_station/platform_track_catenary.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [8401010] = {
          metadata = {
            track = true,
          },
          name = "station/rail/modular_station/platform_track_catenary.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [10400000] = {
          metadata = {
            platform_roof = true,
          },
          name = "station/rail/modular_station/platform_passenger_roof_era_b.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [10400010] = {
          metadata = {
            platform_roof = true,
          },
          name = "station/rail/modular_station/platform_passenger_roof_era_b.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
        [10800000] = {
          metadata = {
            underground = true,
          },
          name = "station/rail/modular_station/addon_platform_passenger_stairs_era_b.module",
          updateScript = {
            fileName = "",
            params = { },
          },
          variant = 0,
        },
      },
		}]]--
		



		local context = api.type.Context.new()
		context.cleanupStreetGraph = cleanupStreetGraph:isSelected()
		context.checkTerrainAlignment = checkBoxAlignTerrain:isSelected()
		context.gatherBuildings = gatherBuildings:isSelected() 
		context.player = game.interface.getPlayer()
		trace("About to build command")
		local build = api.cmd.make.buildProposal(newProposal, context, ignoreErros:isSelected())
		trace("About to sent command")
		--if tracelog then debugPrint(build) end
		api.cmd.sendCommand(build, function(res, success) 
			debuglog(" attempt command result was", tostring(success))
			if success then 
			--	failedCount = failedCount - 1
				successCount= successCount + 1
				--debugPrint(res)
				
				local addedNodes = {}
				local addedSegments = {}
				--for i, node in pairs(res.proposal.proposal.addedNodes) do
				--	table.insert(addedNodes, node.entity)
				--end
				local alreadySeen = {}
				for i, tn in pairs(res.resultProposalData.entity2tn) do
					if #tn.nodes > 0 then
						table.insert(addedNodes, i)
					else 
						table.insert(addedSegments, i)
					end
				--[[	for j, tn in pairs(seg.edges) do
						for k = 1, 2 do
							local node = tn.conns[k].entity
							if not alreadySeen[node] then 
								alreadySeen[node]=true
								table.insert(addedNodes, node)
							end
						end
					end]]--
				end
				table.insert(lastResults, { addedNodes = addedNodes, addedSegments = addedSegments})
				toggleUndo()

					
				--res.resultProposalData.streetProposal.
			else
--[[			
				if #orderedCityPairs > index then
					debuglog("Could not connect ", town1.name, " with ", town2.name, " attempting next")
					table.insert(workItems, function() xpcall(function() connectTowns(orderedCityPairs, index+1) end, err) end)
					needsupdate=true
				 
				else
					failedCount = failedCount + 1
				--if debuglog then debugPrint(res) end
					debugPrint(res.resultProposalData.errorState)
				end--]]
			end
			--updateView()
			resultView:setText(successCount.._(' connections built. ')..#workItems.._(' remaining ')..failedCount.._(' failed'))
			workComplete = true
		end )
	end
	
	local function setTangent(tangent, t) -- because tangent is mysterious "userdata", can't give it a vec3
		tangent.x = t.x
		tangent.y = t.y
		tangent.z = t.z
	end
	local function setTangent2d(tangent, t) -- because tangent is mysterious "userdata", can't give it a vec3
		tangent.x = t.x
		tangent.y = t.y 
	end
	
	local function connectTowns(orderedCityPairs, index)
		local orderedCityPairsCount = 0
		for ___,____ in pairs(orderedCityPairs) do orderedCityPairsCount = orderedCityPairsCount + 1 end -- oh lua
	
		if index > orderedCityPairsCount then
			trace("exiting connectTowns early, requested index=",index, " orderedCityPairsCount=",orderedCityPairsCount)
			workComplete = true
			return
		end
		local citypair = orderedCityPairs[index]
		local town1 = citypair[1]
		local town2 = citypair[2]
		debuglog("attempting to connect ",town1.name," with ",town2.name)
		local searchRadius = math.min(500, math.floor(hypotlen2(town1.position, town2.position)/2.1))
		local town1xypos = vec2.new(town1.position[1],town1.position[2])
		local town2xypos = vec2.new(town2.position[1],town2.position[2])
		local straightlinevec = vec2.sub(town1xypos,town2xypos)
		local perpvector = vec2.rotate90(straightlinevec)
		debugPrint({perpvector=perpvector})
		local town1Nodes = findDeadEndNodesWithinAngel(town1,searchRadius,stationAngleThreashold,perpvector) 
		local town2Nodes = findDeadEndNodesWithinAngel(town2,searchRadius,stationAngleThreashold,perpvector)  

		 
		local nodepair = findShortestDistanceNodePair(town1Nodes, town2Nodes)
	 
		if not nodepair then
			trace("failed to find any nodes")
			connectTowns(orderedCityPairs, index+1)
			return
		end
		local shortest = nodepair[3]

		--local targetSeglenth = 90
		local nodecount = math.floor(shortest/targetSeglenth)
		if tracelog then debugPrint({nodepair=nodepair}) end
		local leftnode = nodepair[1]
		local rightnode = nodepair[2]
		

		local leftEdgeId = api.engine.system.streetSystem.getNode2StreetEdgeMap()[leftnode]:at(1) -- note second table is C Vector
		local rightEdgeId = api.engine.system.streetSystem.getNode2StreetEdgeMap()[rightnode]:at(1)
		local leftEdge = api.engine.getComponent(leftEdgeId, api.type.ComponentType.BASE_EDGE)
		local rightEdge = api.engine.getComponent(rightEdgeId, api.type.ComponentType.BASE_EDGE)
		local lf = leftnode == leftEdge.node1 and 1 or -1
		local lefttangent = leftnode == leftEdge.node0 and leftEdge.tangent0 or leftEdge.tangent1
		local rf = rightnode == rightEdge.node0 and 1 or -1
		local righttangent = rightnode == rightEdge.node1 and rightEdge.tangent1 or rightEdge.tangent0
		
	
		local seglenght = shortest / (1 + nodecount) 

	
		lefttangent = lf*v3(lefttangent)
		righttangent = rf*v3(righttangent)
		
		local leftNodePos = nodePos(leftnode)
		local rightNodePos =nodePos(rightnode)
		
		local offset = 30
		local nrmlrighttrangent = vec3.normalize(righttangent)
		local nrmllefttrangent = vec3.normalize(lefttangent)
		local leftstationPos = offset * nrmllefttrangent +leftNodePos
		local leftangel = vec2.angle(nrmllefttrangent, vec2.new(1,0))
		local rightstationPos = -offset * nrmlrighttrangent + rightNodePos
		local rightangel =  vec2.angle(nrmlrighttrangent, vec2.new(1,0))
		local leftstationtransf = transf.rotZTransl(leftangel, leftstationPos)
		local rightstationtransf = transf.rotZTransl(rightangel+math.rad(180), rightstationPos)
		local function transf2Mat4f(trnsf)
			local vec4fs = {}
			for i = 1, 16, 4 do
				table.insert(vec4fs, api.type.Vec4f.new(trnsf[i], trnsf[i+1], trnsf[i+2], trnsf[i+3]))
			end
			
			return api.type.Mat4f.new(vec4fs[1], vec4fs[2],vec4fs[3],vec4fs[4]);
		end
		
		local bustopmodels = {"station/bus/small_old.mdl","station/bus/small_mid.mdl","station/bus/small_new.mdl"}
		local busstop
		for i, name in pairs(bustopmodels) do
			-- api.res.modelRep.get(api.res.modelRep.find("station/bus/small_old.mdl"))
			local modelId = api.res.modelRep.find(name)
			local modelDetail = api.res.modelRep.get(modelId)
			--if tracelog then debugPrint({name=name,modelId=modelId,modelDetail=modelDetail}) end
			if filterYearFromAndTo(modelDetail.metadata.availability) then
				trace("using model ",modelId," name=",name," for bus stop")
				busstop=name
				break
			end
		end
		local newProposal = api.type.SimpleProposal.new()
		local function buildBusStop(edgeId)
			trace("begin building bus stop for edge",edgeId)
			local leftCopy = copyEntity(edgeId)
			local nextEdgeId = -(1+#newProposal.streetProposal.edgesToAdd)
			local nextObjectId = -(1+#newProposal.streetProposal.edgeObjectsToAdd)
			leftCopy.entity = nextEdgeId
			local objects = deepClone(leftCopy.comp.objects)
			table.insert(objects,  { nextObjectId, 1})
			leftCopy.comp.objects = objects -- for some reason have to reassign the table
			if tracelog then debugPrint(leftCopy) end
			trace("about to set edges to remove on proposal at ",-nextEdgeId)
			newProposal.streetProposal.edgesToRemove[-nextEdgeId]=edgeId
			trace("about to set edges to add on proposal")
			newProposal.streetProposal.edgesToAdd[-nextEdgeId]=leftCopy
			local newStop = api.type.SimpleStreetProposal.EdgeObject.new()
			newStop.left = false
			newStop.oneWay = false
			newStop.playerEntity = api.engine.util.getPlayer()
			newStop.edgeEntity = nextEdgeId
			newStop.name = "stop"-- api.engine.getComponent(edgeId, api.type.ComponentType.NAME).name
			newStop.model = busstop
			local length = hypotlen(nodePos(leftCopy.comp.node0),nodePos(leftCopy.comp.node1))
			trace("len was ",length)
			local dist = length / 2
			trace("setting bus stop param to ", dist)
			newStop.param = 0.5
			trace("about to set objects to add on proposal index",-nextObjectId)
			newProposal.streetProposal.edgeObjectsToAdd[-nextObjectId]=newStop
			trace("end building bus stop")
		end
		if buildBusStops:isSelected() then
			buildBusStop(leftEdgeId)
		end
		local centerEdge1Id = game.interface.getEntities({radius=10, pos = town1.position},{type="BASE_EDGE"})
		if centerEdge1Id and #centerEdge1Id > 0 then
			trace("Looking to build at central bus stop at ",centerEdge1Id[1])
			if buildBusStopsTown:isSelected() then
				buildBusStop(centerEdge1Id[1])
			end
		end
		 
		
		local roadDepot = "depot/road_depot_era_a.con"
		local leftDepotTangent
		local leftDepotNode
		local function buildDepot(town, notnode)
			for node, nodePos in pairs(findDeadEndNodes(town1,searchRadius)) do
				if node ~= notnode then
				
					local roadDepotConstruction = api.type.SimpleProposal.ConstructionEntity.new()
					roadDepotConstruction.fileName = "depot/road_depot_era_a.con"
					roadDepotConstruction.playerEntity = api.engine.util.getPlayer()
					 roadDepotConstruction.params={
						paramX = 0,  
						paramY = 0, 
						seed = 0, 
						year = year()}
					local edgeId = api.engine.system.streetSystem.getNode2StreetEdgeMap()[node]:at(1)
					local baseEdge = api.engine.getComponent(edgeId, api.type.ComponentType.BASE_EDGE)
					local positive = node == baseEdge.node1
					local tangent = v3(positive and baseEdge.tangent0 or baseEdge.tangent1 )
					if tracelog then debugPrint({tangent=tangent, baseEdge=baseEdge}) end
					local offset = positive and roadDepotPoistionOffset or -roadDepotPoistionOffset
					local depotPos = offset*vec3.normalize(tangent)+v3fromArr(nodePos)
					local rotation = vec2.angle(tangent,vec2.new(1,0))+math.rad(roadDepotExtraAngle)
					local trnsf = transf.rotZTransl(rotation, depotPos)
					if tracelog then debugPrint({depotTransf=trnsf, rotation=math.deg(rotation)}) end
					roadDepotConstruction.transf = transf2Mat4f(trnsf)
					return { construction = roadDepotConstruction, tangent=tangent, node=node}
				end
			end
		end
		local roadDepotConstruction1 = buildDepot(town1, leftnode)
		
		
		local tracktype = api.res.trackTypeRep.find("standard.lua")
		--debugPrint({stationtransf=stationtransf, mat4f=transf2Mat4f(stationtransf)})
		local basestationparams = { 
		catenary = 0,  
		length = 1, 
		paramX = 0,  
		paramY = 0, 
		seed = 0, 
		templateIndex = 2, 
		trackType = 0,  -- 0 == standard, 1== high speed, NOT the same as api.res.trackTypeRep
		tracks = doubleTrack:isSelected() and 0 or 1,
		year = year(),}

		--[[
		
		if not stationCreateTemplateFn then
			loadfile("res/construction/station/rail/modular_station/modular_station.con")
			local thedata = data()
			stationCreateTemplateFn = thedata.createTemplateFn
			debugPrint(thedata)
			print("loaded file, thedata ",thedata," stationCreateTemplateFn=",stationCreateTemplateFn)
		end]]--
		--debugPrint(helper)
		local function createStationConstruction(stationtransf)
			local stationParams = deepClone(basestationparams)
			local modulebasics = helper.createTemplateFn(stationParams)
			local modules = {}
			for i,name in pairs(modulebasics) do
				local detail = api.res.moduleRep.get(api.res.moduleRep.find(name))
				modules[i]={
					metadata=deepClone(detail.metadata),
					name=name,
					updateScript= {
						fileName=detail.updateScript.fileName,
						params = deepClone(detail.updateScript.params)
					},
					variant = 0,
				}
			end
					 local newConstruction = api.type.SimpleProposal.ConstructionEntity.new()
			 local station = "station/rail/modular_station/modular_station.con"
			 local stationConstr = api.res.constructionRep.get(api.res.constructionRep.find(station))
			 --api.res.constructionRep.get(api.res.constructionRep.find("station/rail/modular_station/modular_station.con")).constructionTemplates[1]
			 local template = stationConstr.constructionTemplates[1]
			 newConstruction.fileName = station
			 newConstruction.playerEntity = api.engine.util.getPlayer()
			 stationParams.modules = modules
			 newConstruction.params = stationParams
--[[				newConstruction.params = {
			  autoRoofs = 1,
			  buildingSize = 4,
			  buildingStyle = 3,
			  catenary = 1,
			  length = 2,
			  paramX = 0,
			  paramY = 0,
			  templateIndex = 2,
			  seed = 0,
			  trackType = 0,
			  tracks = 0,
			  year = 1925,
			  modules = modules
			  }]]--
			--[[newConstruction.transf:cols(0).x=1 -- scale
			newConstruction.transf:cols(1).y=1 -- scale
			newConstruction.transf:cols(2).z=1 -- scale
			newConstruction.transf:cols(3).x=stationPos.x
			newConstruction.transf:cols(3).y=stationPos.y
			newConstruction.transf:cols(3).z=stationPos.z
			newConstruction.transf:cols(3).w=1 -- not a clue what this is for--]]

			newConstruction.transf = transf2Mat4f(stationtransf)

			--debugPrint({cols0=newConstruction.transf:cols(0),cols1=newConstruction.transf:cols(1),cols2=newConstruction.transf:cols(2),cols3=newConstruction.transf:cols(3)})
			return newConstruction
		end

		--if tracelog then debugPrint({newConstructionparams =newConstruction.params })end
		--api.gui.util.getById( "menu.construction.rail.rail-buildings.item.station/rail/modular_station/modular_station.con_2")
		
		newProposal.constructionsToAdd[1]=createStationConstruction(leftstationtransf)
		newProposal.constructionsToAdd[2]=createStationConstruction(rightstationtransf)
		if buildRoadDepot:isSelected() then
			newProposal.constructionsToAdd[1+#newProposal.constructionsToAdd]=roadDepotConstruction1.construction
		end
		local context = api.type.Context.new()
		context.cleanupStreetGraph = cleanupStreetGraph:isSelected()
		context.checkTerrainAlignment = checkBoxAlignTerrain:isSelected()
		context.gatherBuildings = gatherBuildings:isSelected() 
		context.player = game.interface.getPlayer()
		trace("About to build command")
		local build = api.cmd.make.buildProposal(newProposal, context, ignoreErros:isSelected())
		trace("About to sent command")
		 if tracelog then debugPrint({build=build}) end
		api.cmd.sendCommand(build, function(res, success) 
			debuglog(" attempt command result was", tostring(success))
			if success then 
			--	failedCount = failedCount - 1
				successCount= successCount + 1
				--debugPrint(res)
				local addedNodes = {}
				local addedSegments = {}
			
				addUndo(res)

				local function waitTest()
					for i, tn in pairs(res.resultProposalData.entity2tn) do
						if #tn.nodes > 0 then
							local edges = api.engine.system.streetSystem.getNode2StreetEdgeMap()[i]
							return edges and #edges > 0
						end
					end
				end

				table.insert(workItems, function()
					trace("begin connecting stations")
					local deadEndNodesLeft = {}
					local deadEndNodesRight = {}
					local alreadySeen = {}
					local depotSegments = {}
					for i, seg in pairs(res.resultProposalData.entity2tn) do
							trace("inspecting  res.resultProposalData.entity2tn at ",i)
						if i == res.resultEntities[1] then 
							trace("found left " ,i)
						elseif i == res.resultEntities[2] then
							trace("found right ",i)
						
						end
						--if #tn.nodes > 0 then
							--[[
						--	if tn.transportModes[8]==1 then
							local edges = api.engine.system.streetSystem.getNode2StreetEdgeMap()[i]
							trace("inspecting node ",i, "#edges ",( edges and #edges or nil))
							if edges and #edges==1 then
								local edge = edges:at(1)
								if res.resultProposalData.entity2tn[edge].edges[1].transportModes[8]==1 then
									if edge==res.resultEntities[1] then
										table.insert(deadEndNodesLeft,i)
									else 
										table.insert(deadEndNodesRight,i)
									end
								end
							end]]--
							
						--else 
					  	for j, tn in pairs(seg.edges) do
							if tn.transportModes[8]==1 then
								local owner = api.engine.system.streetConnectorSystem.getConstructionEntityForEdge(i)
								local left = owner == res.resultEntities[1]
								local right = owner == res.resultEntities[2]
								for k = 1, 2 do
									local node = tn.conns[k].entity
									if not alreadySeen[node] then 
										alreadySeen[node]= { owners = 1, left = left, right=right, seg=i}
									else 
										alreadySeen[node]= { owners = 2, left = left, right = right}
									end
								end
							elseif tn.transportModes[3]==1 then 
								local owner = api.engine.system.streetConnectorSystem.getConstructionEntityForEdge(i)
								local left = owner == res.resultEntities[3]
								local right = owner == res.resultEntities[4]
								if left or right then
									local nodes = {}
									local index = 0
									for k = 1, 2 do
										table.insert(nodes, tn.conns[k].entity)
										index = tn.conns[k].index
									end
									table.insert(depotSegments, { nodes=nodes, left = left, right=right, seg=i, tangent=tn.geometry.params.tangent, pos=tn.geometry.params.pos, index=index})
								end
								
							end
						end 
					end
					local depot1 =res.resultEntities[3]
					local depot2 = res.resultEntities[4]
					--if tracelog then debugPrint({alreadySeen=alreadySeen}) end
					if tracelog then debugPrint({depotSegments=depotSegments}) end
					
					table.insert(workItems, function()
						local newProposal = api.type.SimpleProposal.new()
						local count = 0
						local leftDepotId 
						for i, seg in pairs(depotSegments) do 
							if seg.left then
								count = count + 1
								local entity = api.type.SegmentAndEntity.new()
								entity.entity = -count
								entity.type = 0 
								entity.comp.node0 = roadDepotConstruction1.node
								setTangent(entity.comp.tangent0, roadDepotConstruction1.tangent)
								entity.comp.node1 = seg.nodes[1]
								setTangent2d(entity.comp.tangent1, seg.tangent)
								local streetTypeName = year() >= 1925 and "standard/town_medium_new.lua" or "standard/town_medium_old.lua"
								entity.streetEdge.streetType = api.res.streetTypeRep.find(streetTypeName)
								debugPrint({roadLinkEntity=entity})
								newProposal.streetProposal.edgesToAdd[count]=entity
								leftDepotId = api.type.NodeId.new(seg.nodes[2],seg.index)
								break
							end
						end
						local context = api.type.Context.new()
						context.cleanupStreetGraph = cleanupStreetGraph:isSelected()
						context.checkTerrainAlignment = checkBoxAlignTerrain:isSelected()
						context.gatherBuildings = gatherBuildings:isSelected() 
						context.player = game.interface.getPlayer()
						trace("About to build command")
						local build = api.cmd.make.buildProposal(newProposal, context, ignoreErros:isSelected())
						trace("About to sent command")
						api.cmd.sendCommand(build, function(res, success) 
							trace("result was ",success)
							if success then
								table.insert(workItems, function() 
									local playerEntity = game.interface.getPlayer()
									--local depotEntity = api.engine.system.vehicleDepotSystem.getDepotForInNodeId(leftDepotId)
									local depotEntity = api.engine.getComponent(depot1 ,api.type.ComponentType.CONSTRUCTION).depots[1]
									trace("got depotEntity=",depotEntity)
									if depotEntity == -1 then
										workComplete = true
										return
									end
									
									if tracelog then debugPrint({leftDepotId=leftDepotId}) end
									local config = api.type.TransportVehicleConfig.new()
									local vehiclePart = api.type.TransportVehiclePart.new()
									
									for i, name in pairs(api.res.modelRep.getAll()) do
										if string.find(name, "vehicle/bus/") then
											local model = api.res.modelRep.get(i)
											if filterYearFromAndTo(model.metadata.availability) then
												vehiclePart.part.modelId = i 
												break
											end
										end
									end
									vehiclePart.part.loadConfig={0}
									vehiclePart.autoLoadConfig={1}
									config.vehicles[1]=vehiclePart
									config.vehicleGroups[1]=1
									local buyVehicle = api.cmd.make.buyVehicle(playerEntity,depotEntity, config)
									debugPrint({buyVehicle=buyVehicle})
									api.cmd.sendCommand(buyVehicle, function(res, success) 
										trace("buyVehicle result was ",success)
										if success then 
											local resultVehicle = res.resultVehicleEntity 
											table.insert(workItems, function() 
												local color = game.config.gui.lineColors[nextLineColor]
												color = api.type.Vec3f.new(color[1],color[2],color[3])
												nextLineColor = nextLineColor+1
												if nextLineColor > #game.config.gui.lineColors then
													nextLineColor = 1
												end
												local stations = api.engine.system.stationSystem.getStations(town1.id)
												
												local line = api.type.Line.new()
												for i, station in pairs(stations) do 
													local details = api.engine.getComponent(station, api.type.ComponentType.STATION)
													if not details.cargo then
														local vehicleNode = details.terminals[1].vehicleNodeId
														local edge = api.engine.getComponent(vehicleNode.entity, api.type.ComponentType.BASE_EDGE)
														if edge and edge.type==0 then
															local stop = api.type.Line.Stop.new()
															stop.stationGroup =api.engine.system.stationGroupSystem.getStationGroup(station)
															--stop.station=station
															--stop.terminal=1
															stop.station = 0
															stop.terminal = 0
															line.stops[#line.stops+1]=stop
														end
													end
												end
												local transportModes = line.vehicleInfo.transportModes
												transportModes[4]=1--BUS
												line.vehicleInfo.transportModes = transportModes -- seems to be necessary for some reason, hidden pass by value not reference? 
												if tracelog then debugPrint({line=line})  end
												local create = api.cmd.make.createLine("Bus line", color, game.interface.getPlayer(), line)
												api.cmd.sendCommand(create, function(res, success) 
													trace("create line success=",success)
														if tracelog then debugPrint({createLineRes=res}) end
													if success then 
														table.insert(workItems, function() 
															local setLine = api.cmd.make.setLine(resultVehicle, res.resultEntity, 1)
															api.cmd.sendCommand(setLine, function(res, success) 
																trace("setting vehicle on line was: ",success)
																if tracelog then debugPrint({setLineRes=res}) end
																workComplete = true
															end)
														end)
														needsupdate = true
													end
													workComplete=true
												end)
											end)
											needsupdate=true
										end
										debugPrint({buyVehicleres=res})
										workComplete=true
									end)
								end)
								needsupdate=true
							end
							workComplete=true
						end)
						
						
					end)
					needsupdate=true
					
					local node2SegMap = {}
					for node, info in pairs(alreadySeen) do
						if info.owners==1 then
							node2SegMap[node]=info.seg
							if info.left then
								deadEndNodesLeft[node]=nodePos2(node)

							else
								deadEndNodesRight[node]=nodePos2(node)
							end
						end
					end
					if tracelog then debugPrint({deadEndNodesLeft=deadEndNodesLeft, deadEndNodesRight=deadEndNodesRight}) end
					
					local nodepair = findShortestDistanceNodePair(deadEndNodesLeft, deadEndNodesRight)	
					if nodepair then 
						connectTowns2(nodepair, true, node2SegMap)
					else
						print("ERROR COULD NOT FIND A NODEPAIR")
						workComplete = true
					end
				end)
				local function waitFunction()
					trace("in dummy function")
					if not waitTest() then 
						trace("wait test failed, adding another wait")
						table.insert(workItems, waitFunction)
					end
					needsupdate = true
					workComplete = true
				end
				
				--table.insert(workItems, waitFunction)
				needsupdate = true
				--res.resultProposalData.streetProposal.
			else	
			--[[	if #orderedCityPairs > index then
					debuglog("Could not connect ", town1.name, " with ", town2.name, " attempting next")
					table.insert(workItems, function() xpcall(function() connectTowns(orderedCityPairs, index+1) end, err) end)
					needsupdate=true
				 
				else]]--
					failedCount = failedCount + 1
				--if debuglog then debugPrint(res) end
					debugPrint(res.resultProposalData.errorState)
				--end
			end
			--updateView()
			resultView:setText(successCount.._(' connections built. ')..#workItems.._(' remaining ')..failedCount.._(' failed'))
			workComplete = true
		end )
		end
		
		
		
	
	local button2 = newButton(_('Build new city connections (experimental)'))
	 trace("added button 2")
	 button2:onClick(
	 function() table.insert(workItems,
		function() 
		xpcall(function()
			successCount =0
			failedCount = 0
			local alreadySeen ={}
			collectgarbage()
			
			for townId, town in pairs(game.interface.getEntities(circle, {type="TOWN", includeData=true})) do
				local dists = {}
				local cityPairsByDist = {}
				local position = town.position
				alreadySeen[townId]=true
	 
				trace("Inspecting town ", town.name)
				--debugPrint({baseEdges = game.interface.getEntities({ radius=100, pos=position}, {type="BASE_EDGE", includeData=true})})
				local baseEdge  = findUrbanStreetsForTown(town, 100)[1]
				--for edgeId 
				-- { 2088, 1708, 2.0999984741211, }
				-- game.interface.getEntities({ radius=10, pos= { 2088, 1708, 2.0999984741211, }}, {type="BASE_EDGE", includeData=true})[1]
				--game.interface.getEntities({ radius=10, pos=position}, {type="BASE_EDGE", includeData=true}) 
				-- api.type.EdgeIdDirAndLength.new(api.type.EdgeId.new(),true,100)
				
				-- 93073
--				edgeId.entity = baseEdge
				local startingEdges= {}
				local mode = 3
				--local startEdgeIdDirAndLength = api.type.EdgeIdDirAndLength.new(edgeId, true, 0)
				--local startEdgeIdDirAndLength2 = api.type.EdgeIdDirAndLength.new(edgeId, false, 0)
				for i, tn in pairs(api.engine.getComponent(baseEdge.id,api.type.ComponentType.TRANSPORT_NETWORK).edges) do
						--debugPrint(tn)
						if tn.transportModes[mode]==1 then
							local edgeId = api.type.EdgeId.new(baseEdge.id, i)
							table.insert(startingEdges,api.type.EdgeIdDirAndLength.new(edgeId, true, 0))
							table.insert(startingEdges,api.type.EdgeIdDirAndLength.new(edgeId, false, 0))
							break
						end
					end
				
				for town2Id, town2  in pairs(game.interface.getEntities({ radius=townSearchDistance, pos=position}, {type="TOWN", includeData=true})) do
					if alreadySeen[town2Id] then
						trace("skipping ", town2.name, " as it was already seen")
						goto continue
					end
					debuglog("start of loop iteration, lua used memory=",api.util.getLuaUsedMemory())
					local distance = hypotlen2( position , town2.position) -- straight line distance
					trace("straight line distance between ", town.name, " and ", town2.name, " was ", distance)
					--local b1 = api.engine.system.townBuildingSystem.getTown2BuildingMap()[townId][1]
					--api.engine.getComponent(b1, api.type.ComponentType.TOWN_BUILDING).parcels[1]
					local baseEdge2 = findUrbanStreetsForTown(town2, 100)[1]
					local destNodes = {}
					trace("inspecting edge ",baseEdge2.id)
					for i, tn in pairs(api.engine.getComponent(baseEdge2.id,api.type.ComponentType.TRANSPORT_NETWORK).edges) do
						--debugPrint(tn)
						if tn.transportModes[mode]==1 then
							trace("transport node dest found inserting for i",i)
							table.insert(destNodes, api.type.NodeId.new(tn.conns[1].entity, tn.conns[1].index))
							table.insert(destNodes, api.type.NodeId.new(tn.conns[2].entity, tn.conns[2].index))
							break
						else
							trace("transport mode not applicable",i)
						end
					end
					
					
					
					--local destNode =  api.type.NodeId.new(api.engine.getComponent(baseEdge2.id, api.type.ComponentType.BASE_EDGE).node0  ,0)
					--local destNode2 =  api.type.NodeId.new(api.engine.getComponent(baseEdge2.id, api.type.ComponentType.BASE_EDGE).node1  ,0)
					--local tn = api.engine.getComponent(baseEdge2, api.type.ComponentType.TRANSPORT_NETWORK)
					--local transportModes = { 0 ,0 ,1 ,1 ,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 }
					--local transportModes = { 1,1 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 ,0 }
					local transportModes = {  api.type.enum.TransportMode.CAR} 
					trace("Attempting to find path")
					--if tracelog then debugPrint({start=startingEdges , endNode= destNodes}) end
					local answer = api.engine.util.pathfinding.findPath( startingEdges , destNodes, transportModes, 1.5*distance+100)
					--if tracelog then debugPrint({startNode={startEdgeIdDirAndLength, startEdgeIdDirAndLength2 } , destNode=destNodes, transportModes=transportModes, distance=2*distance}) end
					if #answer == 0 then
						debuglog("NO path was found between ", town.name, " and ", town2.name)
						table.insert(dists, distance)
						cityPairsByDist[distance] = { town, town2}
					else
						debuglog("a path WAS found between ", town.name, " and ", town2.name, " with ", #answer, " answers")
					end
					debuglog("end of loop iteration, lua used memory=",api.util.getLuaUsedMemory())
					
					--debugPrint(answer) -- returns array BASE_EDGE

				::continue::
				end
			
				table.sort(dists)
				local orderedCityPairs = {}
				for i=1, #dists do
					local dist = dists[i]
					local citypair = cityPairsByDist[dist]
					table.insert(orderedCityPairs, citypair)
					--if tracelog then debugPrint({i=i, dist=dist, citypair=citypair}) end
				 
				end
				if #orderedCityPairs > 0 then
					table.insert(workItems, function() xpcall(function() connectTowns(orderedCityPairs, 1) end, err) end)
					needsupdate=true
				end
				debuglog("before collect garbage lua used memory=",api.util.getLuaUsedMemory())
				collectgarbage()
				debuglog("after collect garbage lua used memory=",api.util.getLuaUsedMemory())
			end
			if #workItems == 0 then
				resultView:setText(_('No new connection possibilities were found'))
			end
			trace("The number of workItems is ", #workItems)
			workComplete = true
		end,
		err)	 
		end)
		needsupdate=true
	end)
	local newBuildButtonLayout =  api.gui.layout.BoxLayout.new("HORIZONTAL");
	newBuildButtonLayout:addItem(button2)
	trace("added button2")
	newBuildButtonLayout:addItem(button4)
	trace("added button4")
	boxlayout:addItem(newBuildButtonLayout)
	trace("added newBuildButtonLayout")
	boxlayout:addItem(resultView)
		local comp= api.gui.comp.Component.new("AIBuildertrain")
	comp:setLayout(boxlayout)
	trace("called comp:setLayout")
	--comp:setLayout(api.gui.layout.BoxLayout.new("HORIZONTAL"))
	return {
		comp = comp,
		refresh = function()
			resultView:setText(" ")
			--populateChoices() 
		end
	}
end
local function debugPanel() 
	local boxlayout = api.gui.layout.BoxLayout.new("VERTICAL");
	local textInput = api.gui.comp.TextInputField.new( "ALL")
	-- textInput:setText()
	boxlayout:addItem(textInput)
	local checkIncludeData = api.gui.comp.CheckBox.new(_("Include data"))
	boxlayout:addItem(checkIncludeData)
	local button  = newButton(_('Dump entity data to console'))
	boxlayout:addItem(button)
	button:onClick(function() 
		xpcall(function()
		print("about to call getEntities for type=",textInput:getText()," includeData=",checkIncludeData:isSelected() )
		local filter = {includeData = checkIncludeData:isSelected()}
		local text = textInput:getText()
		if text and text~="" and text~="ALL" then
			filter.type = text
		end
		local entities = game.interface.getEntities(circle,filter)
		debugPrint(entities)
		end, err)
		
	end)
	
	local comp= api.gui.comp.Component.new("AIBuilderdebug")
	comp:setLayout(boxlayout)
	return {
		comp = comp,
		refresh = function()
 
		end
	}
end


local function buildWindow()
	
	local buttongroup = api.gui.comp.ToggleButtonGroup.new(api.gui.util.Alignment.HORIZONTAL, 0, false)
	local globalToggle = api.gui.comp.ToggleButton.new(api.gui.comp.TextView.new(_('Global')))
	local radiusToggle = api.gui.comp.ToggleButton.new(api.gui.comp.TextView.new(_('Within circle')))
	globalToggle:setSelected(true, false)
	buttongroup:add(globalToggle)
	buttongroup:add(radiusToggle)
	buttongroup:setOneButtonMustAlwaysBeSelected(true)
	buttongroup:onCurrentIndexChanged(function(x)
		if x == 1 then 
			updateCircle()
			needsupdate = true
		else 
			needsupdate = false
			remZone("ai_builder")
			circle.radius = math.huge
		end
	end)
	local boxlayout = api.gui.layout.BoxLayout.new("VERTICAL");
	boxlayout:addItem(buttongroup)
	errorPanel = api.gui.comp.TextView.new(" ")
	local tab = api.gui.comp.TabWidget.new("NORTH")
	--local streetUpgrade = buildStreetUpgradePanel()
	--local bridgeUpgrade =buildBridgeUpgradePanel()
	--local tramupgrade = buildTramUpgradePanel()
	--local trainUpgrade =buildTrainUpgradePanel()
	-- local straighten =
		local straighten = buildStraightenPanel()
		local de
	xpcall(function() 
		print("about to build straighten panel")
	
		print("finished to build straighten panel. About to add tab")
		tab:addTab(api.gui.comp.TextView.new(_('Trains')), straighten.comp)
		print("finished add tab")
		end
	,err)
	--tab:addTab(api.gui.comp.TextView.new(_('Streets')), streetUpgrade.comp )
	--tab:addTab(api.gui.comp.TextView.new(_('Train')), trainUpgrade.comp )
	--tab:addTab(api.gui.comp.TextView.new(_('Tram')), tramupgrade.comp)
	--tab:addTab(api.gui.comp.TextView.new(_('Bridges')), bridgeUpgrade.comp)
	 --tab:addTab(api.gui.comp.TextView.new(_('Trains')), straighten.comp)
	tab:addTab(api.gui.comp.TextView.new(_('Debug')), debugPanel().comp)
	boxlayout:addItem(tab)
	local bottomPanel =  api.gui.layout.BoxLayout.new("HORIZONTAL");
	abortButton = newButton(_('Abort'))
	
	bottomPanel:addItem(abortButton)
	bottomPanel:addItem(errorPanel)
	boxlayout:addItem(bottomPanel)
	abortButton:onClick(function() 
		workItems={} 
		abortButton:setEnabled(false)
		workComplete = true
	end)
	abortButton:setEnabled(false)
    local window = api.gui.comp.Window.new(_('AI Builder'), boxlayout)

	 window:addHideOnCloseHandler()
	 window:onClose(function() 
		globalToggle:setSelected(true,true)
	 end)
	return {
		window = window,
		refresh = function() 
			--streetUpgrade.refresh()
			--bridgeUpgrade.refresh()
			--trainUpgrade.refresh()
			--tramupgrade.refresh()
			straighten.refresh()
			--tab:setCurrentTab(0,false)
			workComplete = true
		end
	}
end
local init = false
local function createComponents()
	debuglog("createComponents start, lua used memory=",api.util.getLuaUsedMemory())
	local gameBar =  api.gui.util.getById("gameInfo.layout")
	if not gameBar then 
		print("COULD NOT FIND GAME BAR FOR SOME RAESON!")
		return
	end
   -- local label = gui.textView_create("gameInfo.AIBuilder.label", _('Global Upgrade'))
    --local button = gui.button_create("gameInfo.AIBuilder.button", label)
	local button = newButton(_('Ai builder'))
    local window = buildWindow()
		
	button:onClick(function ()
		local mainView = game.gui.getContentRect("mainView")
		local y = math.floor(mainView[4]*(1/3)) 
		local x = math.floor(mainView[3]/2) 
		
		window.window:setPosition(x,y)
		window.window:setVisible(true,false)
		window.refresh()
    end)
    
    --game.gui.boxLayout_addItem("gameInfo.layout", gui.component_create("gameInfo.AIBuilder", "VerticalLine").id)
    --game.gui.boxLayout_addItem("gameInfo.layout", button.id)
	
	--while not gameBar do
	--	gameBar =  api.gui.util.getById("gameInfo.layout")
	--end
	if  gameBar then
		gameBar:addItem(api.gui.comp.Component.new("VerticalLine"))
		gameBar:addItem(button)
		init=true
	else 
		print("COULD NOT FIND GAME BAR FOR SOME RAESON!")
	end
	debuglog("createComponents end, lua used memory=",api.util.getLuaUsedMemory())
end


function data()
    return {
		guiInit = function()
			createComponents()
		end,
		
        guiUpdate = function()
			if not init then createComponents() end
            if needsupdate then
				if hascircle then 
					updateCircle()
				end 
				if #workItems > 0 then
					if workComplete then -- throttle
						workComplete = false 
						xpcall(table.remove(workItems, #workItems), err)
						collectgarbage()
					end
				elseif not hascircle then 
					needsupdate = false
				end
				toggleAbort()
			end
        end,
		guiHandleEvent = function(id, name, param)
			--print("guiHandleEvent with ",id,name,param)
			
			if name == "builder.apply" then
				debugPrint(param)
			end
			
			
			--[[if param and name == "builder.proposalCreate" then
			print("I am here")
			--debugPrint(param.proposal.proposal)
			debugPrint({
				param.proposal.toAdd[1].transf:cols(0),
				param.proposal.toAdd[1].transf:cols(1),
				param.proposal.toAdd[1].transf:cols(2),
				param.proposal.toAdd[1].transf:cols(3)})
			print("I am finished")	
			end]]--
		end,
		handleEvent = function (src, id, name, param)
            if id == "global_upgrade" then
                
				debuglog("Doing upgrade (" ,  param.id ,  ") with " ,  param.fileName, " for ", name)
				
				--aplocal e = game.interface.getEntity(param.id)
				local e = api.engine.getComponent(param.id, api.type.ComponentType.CONSTRUCTION)
				local conparams = e.params
				local atLeastOneChange = false
				--conparams.seed = nil
				if name == "tramelectricupgrade" then
					conparams = deepClone(conparams)
					conparams.tramTrack=2
					atLeastOneChange= true
				else 
					local function transform(x) 
						if x and type(x) == "string" then
						
							local upgradeFrom
							local upgradeTo
							
							if name == "upgradeStationEra" then
								upgradeFrom = param.params.oldEra
								upgradeTo = param.params.newEra
							end
							if name == "highspeedupgrade" then
								upgradeFrom = "_track"
								upgradeTo = "_high_speed_track"
							end
							if name == "electricupgrade" then
								upgradeFrom = "_track"
								upgradeTo = "_track_catenary"
							end
							
							if upgradeFrom and upgradeTo then
								if string.find(x, upgradeFrom) then
									trace("searching ", x ," for string ",upgradeFrom," to replace with ",upgradeTo)
									-- this approach allows us to support mods that follow the same naming conventions
									local result = string.gsub(x, upgradeFrom, upgradeTo)
									if api.res.moduleRep.find(result) ~= -1 then -- guard against doing something invalid
										atLeastOneChange= true
										return result
									else 
										debuglog("Could not find module with name ",result," ignoring")
									end
								end
							else 
								debuglog("Either upgradeFrom or upgradeTo was not populated. upgradeFrom=",upgradeFrom," upgradeTo=",upgradeTo)
							end
						
							
						end
						--[[
						if name == "highspeedupgrade" then
							if x == "station/rail/modular_station/platform_track.module" then 
								return "station/rail/modular_station/platform_high_speed_track.module"
							end
							if x == "station/rail/modular_station/platform_track_catenary.module" then 
								return "station/rail/modular_station/platform_high_speed_track_catenary.module" 
							end
						end
						if name == "electricupgrade" then
							if x == "station/rail/modular_station/platform_track.module" then 
								return  "station/rail/modular_station/platform_track_catenary.module" 
							end
							if x == "station/rail/modular_station/platform_high_speed_track.module" then
								return   "station/rail/modular_station/platform_high_speed_track_catenary.module"
							end
						end--]]
						return x
					end
					conparams = deepClone(conparams, transform)
				end
				if atLeastOneChange then
					debuglog("Attempting upgrade (" ,  param.id ,  ")")
					conparams.seed = nil
					game.interface.upgradeConstruction(param.id, param.fileName, conparams)
					game.interface.setPlayer(param.id, game.interface.getPlayer())
					debuglog("Upgrade finished (" ,  param.id ,  ")")
				else
					debuglog("No changes were found while trying to upgrade (" ,  param.id ,  ")")
				end
			end
        end
    }
end


 