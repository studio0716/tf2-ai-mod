local vec3 = require "vec3"
local streetutil = require "streetutil"
local interchangeutil = require "ai_builder_interchange_util"
local util = require "ai_builder_base_util"

local roadtypes = { "standard/town_medium_new.lua", "standard/town_large_new.lua", "standard/town_x_large_new.lua"}
function data()
return {
	type = "STREET_CONSTRUCTION",
	description = {
		name = _("Small Interchange (AI Builder)"),
		description = _("Simple highway interchange construction, designed to work with the AI builder (can be used standalone too). Although the AI builder will automatically place interchanges if you want finer control of the positioning, place down this prefab near a town and use the AI builder to connect it to another."),
	},
	availability = {yearFrom = 1925

	},
	params = interchangeutil.commonParams(),
--[[
	params = {
		{
			key = "streetTypeSmallInterchange",
			name = _("Number of lanes"),
			values = { ("2"), _("3"), },
			defaultIndex = 0,
			yearFrom = 1850,
			yearTo = 0
		},
				{
			key = "streetTypeSmallInterchangeRamp",
			name = _("Number of lanes (ramp)"),
			values = { ("1"), ("2"), _("3"),("2c"), _("3c"),("4c"), _("5c"), _("6c")  },
			defaultIndex = 1,
			yearFrom = 9999,
			yearTo = 0
		},
		{
			key = "Central",
			name =	_("Central Reservation"),
			values = { _("Tight"), _("Normal"), _("Loose"), _("Extra Wide") },
			defaultIndex = 0,
			yearFrom = 9999,
			yearTo = 0
		},
				{
			key = "Connect",
			name =	_("Connecting road"),
			values = { _("NONE"), _("2 lane road"), _("4 lane road"), _("6 lane road") },
			defaultIndex = 1,
			yearFrom = 1850,
			yearTo = 0
		},
						{
			key = "Number",
			name =	_("Number of junctions"),
			values = { _("1"), _("2"), _("3")},
			defaultIndex = 0,
			yearFrom = 9999,
			yearTo = 0
		},
		
								{
			key = "hiwayheight",
			name =	_("Hiway height"),
			uiType = "SLIDER",
			values = { _("10"),_("15"), _("20"), _("25"), _("30") },
			defaultIndex = 1,
			yearFrom = 1850,
			yearTo = 0
		},
		
{
			key = "length",
			name =	_("Length"),
			uiType = "SLIDER",
			values = { _("50"),_("60"), _("70"), _("80"), _("90"),_("100"), _("110"), _("120"), _("130") },
			defaultIndex = 4,
			yearFrom = 9999,
			yearTo = 0
		},
		
		{
			key = "gap",
			name =	_("Gap between junctions"),
			uiType = "SLIDER",
			values = { _("180"),_("270"), _("360"), _("450"), _("540"),_("630"), _("720"), _("810"), _("900") },
			defaultIndex = 1,
			yearFrom = 9999,
			yearTo = 0
		},
		{
					key = "tail",
			name =	_("Connecting tails "),
			uiType = "SLIDER",
			values = {  _("20"), _("30"), _("40"),_("50"),_("60"), _("70"), _("80"), _("90") },
			defaultIndex = 2,
			yearFrom = 9999,
			yearTo = 0
		},
	},]]--
	order = 6000,
	updateFn = function(params)
		local result = { }

		result.models = { }
		local size = params.aiBuilderInterchangeSize
		local roadedges = {}
		local rampbridge = {}
		local rampground = {}
	
		local tangent = vec3.new(0, 1,0)
		local perpTangent = vec3.new(-1, 0,0)
		local heightOffset = interchangeutil.getHeightOffset(params) 
		local position = vec3.new(0,0,heightOffset)
		local function getCentral(params) 
			local laneCount = params.aiBuilderInterchangeLaneCount+4
			local streetWidth = laneCount * 4
			return (5+streetWidth) / 2
		end
--		local exitAngle = params.aiBuilderInterchangeLaneCount == 0 and math.rad(45) or math.rad(60)
		local exitAngle = math.rad(45)
		local central = interchangeutil.getCentral(params)
		--local centralOffset = 35
		local centralOffset = 30
		local joinPos = 90 
		local tail = 45
		if size == 0 then 
			centralOffset = 35
			joinPos = 80
			tail = 16
			exitAngle = math.rad(60)
		elseif size == 2 then 
			centralOffset = 20
			joinPos = 110 
			tail = 80 
			exitAngle = math.rad(37)
		end		
		local endPos = joinPos+tail
		local outerJoinNode = vec3.new(central+centralOffset,0,0)+position
		local innerJoinNode = vec3.new(-central-centralOffset,0,0)+position
		
		local centerOffset = vec3.new(central,0,0)
		local elevationHeight = 15
		local isUnderground = params.aiBuilderInterchangeLevel == 2
		local isElevated = params.aiBuilderInterchangeLevel == 1
		local isGroundLevel = not isElevated and not isUnderground
		local mainLineOffset = isUnderground and -elevationHeight or isElevated and elevationHeight or 0
		if isGroundLevel then 
			outerJoinNode.z = outerJoinNode.z + elevationHeight
			innerJoinNode.z = innerJoinNode.z + elevationHeight
		end 
		local prevP1 
		local prevP2 
		local mainLine = {}
		
		local function buildRamp(p0, p1, t0, t1, isExit) 
			local dist = util.distance(p0, p1)
			t0 = dist*t0 
			t1 = dist*t1
			--streetutil.addEdge(rampbridge, p0, p1, t0, t1)
			local baseFrac = 0.6
			local frac = isExit and baseFrac or 1-baseFrac
			local s = util.solveForPositionHermiteFraction2(frac, p0, t0, p1, t1)
			streetutil.addEdge(isExit and rampbridge or rampground, p0, s.p, s.t0, s.t1)
			streetutil.addEdge(isExit and rampground or rampbridge, s.p, p1, s.t2, s.t3)
			
		end 
		
		for __ , i in pairs({-endPos, -joinPos, 0, joinPos, endPos}) do 
			local p = position + i*tangent
			p.z = p.z + mainLineOffset
		 
			local p1 = p + centerOffset
			local p2 = p - centerOffset
		 
			--params.leftHandTraffic
		 
			if prevP1 then 
				streetutil.addStraightEdge(mainLine, prevP1, p1)
				streetutil.addStraightEdge(mainLine, p2, prevP2)
			end 
	 
			if math.abs(i) == joinPos  then
				--[[local tangentForRamp = tangent 
				if i > 0 then 
					tangentForRamp = -1*tangent 
				end
				routeBuilder.buildHiwayOnRamp(edgesToAdd, nodesToAdd, newNode , p,tangentForRamp, entity.comp.type, innerJoinNode, innerJoinNodePos, params, nextEdgeId, nextNodeId, i<0, tangentForRamp)
				 routeBuilder.buildHiwayOnRamp(edgesToAdd, nodesToAdd, newNode2 , p2,tangentForRamp, entity2.comp.type, outerJoinNode, outerJoinNodePos, params, nextEdgeId, nextNodeId, i > 0, tangentForRamp) 				
			
			 ]]--
				local tangentForRamp = tangent 
				if i > 0 then 
					tangentForRamp = -1*tangent
					 buildRamp(outerJoinNode, p1,    tangent, util.rotateXY(tangent, exitAngle), false)
					buildRamp(p2, innerJoinNode,    util.rotateXY(-1*tangent,  -exitAngle), -1*tangent, true)					
				else 
					 buildRamp(p1, outerJoinNode, util.rotateXY(tangent, -exitAngle), tangent, true)
					 buildRamp(innerJoinNode, p2, -1*tangent, util.rotateXY(-1*tangent, exitAngle), false)
				end 
				
			end
			prevP1 = p1
			prevP2 = p2 
			 
			--if positionAndRotation.stationRelativeAngle < 0 or  true then
			--	for i, newEdge in pairs(edgesToAdd) do 
			--		util.reverseNewEntity(newEdge)
			--	end 
			--end 
		end 
		streetutil.addStraightEdge(roadedges, outerJoinNode-40*perpTangent, outerJoinNode)
		streetutil.addStraightEdge(roadedges, outerJoinNode, innerJoinNode)
		streetutil.addStraightEdge(roadedges, innerJoinNode, innerJoinNode+40*perpTangent)
	--	streetutil.addStraightEdge(rampbridge, vec3.new(o+ rampmid, -rampoffset,  z2), vec3.new(o+length, -center, z))
	print("road edges wwas",#roadedges)
		local mainLineEdgeType = isElevated and "BRIDGE" or isUnderground and "TUNNEL" or nil
		local mainLineEdgeTypeName = isElevated and "cement.lua" or isUnderground and "street_old.lua" or nil
		
		local groundEdgeType = isGroundLevel and "BRIDGE" or nil
		local groundEdgeTypeName = isGroundLevel and "cement.lua" or nil
		
		result.edgeLists = {
			{
				type = "STREET",
				edgeType = mainLineEdgeType,
				edgeTypeName = mainLineEdgeTypeName,
				params = {
					type = interchangeutil.getRoadType(params),
				},
				edges = mainLine,
				snapNodes =  interchangeutil.findSnapNodes(mainLine, {}),
				freeNodes = streetutil.freeAllNodes(mainLine),
			},

												{
				type = "STREET",
				params = {
					type =  "standard/country_small_one_way_new.lua",

				},
				edgeType = groundEdgeType,
				edgeTypeName = groundEdgeTypeName,
				edges = rampground,
								type = "STREET",
				snapNodes = {},
				freeNodes = streetutil.freeAllNodes(rampground),
			},
												{
				type = "STREET",
				params = {
					type = "standard/country_small_one_way_new.lua",

				},
				edges = rampbridge,
								type = "STREET",
				edgeType = mainLineEdgeType,
				edgeTypeName = mainLineEdgeTypeName,
				snapNodes = {},
				freeNodes = streetutil.freeAllNodes(rampbridge),
			},
		}
		
		if  params.aiBuilderInterchangeConnectRoad > 0 then
			result.edgeLists[#result.edgeLists+1]={
				type = "STREET",
				edgeType = groundEdgeType,
				edgeTypeName = groundEdgeTypeName,
				params = {
					type = roadtypes[params.aiBuilderInterchangeConnectRoad]
				},
				edges = roadedges,
				--snapNodes = #roadedges >0 and {0,#roadedges-1} or { },
				snapNodes = interchangeutil.findSnapNodes(roadedges,result.edgeLists),
				freeNodes = streetutil.freeAllNodes(roadedges),
			}		
		end
		interchangeutil.applySpecialArgs(params, result)
		result.groundFaces = { }

		result.cost = 0

		return result
	end
}

end
